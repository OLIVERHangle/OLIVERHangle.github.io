{"meta":{"title":"阿狐和柴柴","subtitle":"March is a gift.","description":"又是想rua阿狐姐姐的一天","author":"OliverHan","url":"https://www.thripear.space","root":"/"},"pages":[{"title":"","date":"2023-01-01T07:06:33.462Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://www.thripear.space/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"about/index.html","permalink":"https://www.thripear.space/about/index.html","excerpt":"","text":""},{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"404.html","permalink":"https://www.thripear.space/404.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"archives/index.html","permalink":"https://www.thripear.space/archives/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"census/index.html","permalink":"https://www.thripear.space/census/index.html","excerpt":"","text":""},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/index.html","permalink":"https://www.thripear.space/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"friends/index.html","permalink":"https://www.thripear.space/friends/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"categories/index.html","permalink":"https://www.thripear.space/categories/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"resource/index.html","permalink":"https://www.thripear.space/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"tags/index.html","permalink":"https://www.thripear.space/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2023-01-01T07:06:33.468Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/index.html","permalink":"https://www.thripear.space/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/movies/index.html","permalink":"https://www.thripear.space/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/tools/index.html","permalink":"https://www.thripear.space/List/tools/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/music/index.html","permalink":"https://www.thripear.space/List/music/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2023-01-01T07:06:33.469Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://www.thripear.space/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"留言板","date":"2022-11-30T16:00:00.000Z","updated":"2023-02-01T02:54:07.178Z","comments":true,"path":"contact/index.html","permalink":"https://www.thripear.space/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链阿狐和柴柴の友链信息 博客名称: 阿狐和柴柴 博客网址: http://www.thripear.space 博客头像: http://oliverhangleblog.oss-cn-hangzhou.aliyuncs.com/img/avatar.jpg 博客介绍: 即使万众仰慕，我对你一见如故"},{"title":"乖巧小狗","date":"2023-01-01T07:06:33.468Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://www.thripear.space/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2023-01-01T07:06:33.468Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://www.thripear.space/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2023-01-01T07:06:33.468Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://www.thripear.space/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2023-01-01T07:06:33.468Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://www.thripear.space/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2023-01-01T07:06:33.468Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://www.thripear.space/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2023-01-01T07:06:33.468Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://www.thripear.space/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2023-01-01T07:06:33.468Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://www.thripear.space/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2023-01-01T07:06:33.468Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://www.thripear.space/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2023-01-01T07:06:33.468Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://www.thripear.space/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2023-01-01T07:06:33.468Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://www.thripear.space/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2023-01-01T07:06:33.468Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://www.thripear.space/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"Summerschool Python class2","slug":"Summerschool_Python2","date":"2023-06-20T03:25:00.000Z","updated":"2023-06-20T03:12:48.256Z","comments":true,"path":"posts/6b7b24f2.html","link":"","permalink":"https://www.thripear.space/posts/6b7b24f2.html","excerpt":"","text":"Summerschool class2循环复习：打印乘法99表 for an in range(1,10): print('\\n') for bn in range(1,an+1): print(\"{}*{} = {}\".format(an,bn,an*bn),end = \" \") # 注意python的print默认是换行，可以用end = “”制定结束符 # 小心range函数右侧是开括号 1*1 = 1 2*1 = 2 2*2 = 4 3*1 = 3 3*2 = 6 3*3 = 9 4*1 = 4 4*2 = 8 4*3 = 12 4*4 = 16 5*1 = 5 5*2 = 10 5*3 = 15 5*4 = 20 5*5 = 25 6*1 = 6 6*2 = 12 6*3 = 18 6*4 = 24 6*5 = 30 6*6 = 36 7*1 = 7 7*2 = 14 7*3 = 21 7*4 = 28 7*5 = 35 7*6 = 42 7*7 = 49 8*1 = 8 8*2 = 16 8*3 = 24 8*4 = 32 8*5 = 40 8*6 = 48 8*7 = 56 8*8 = 64 9*1 = 9 9*2 = 18 9*3 = 27 9*4 = 36 9*5 = 45 9*6 = 54 9*7 = 63 9*8 = 72 9*9 = 81 列表删除x = [1,2,3] # 指定元素： del x[1] print(x) # 整个列表 del x [1, 3] 插入append()x = [1,2] x.append(5) print(x) [1, 2, 5] insert()x = [1,2,3,4] x.insert(1,5) print(x) [1, 5, 2, 3, 4] extend()运算符# + 运算 注意是列表之间的加法 x = [1,2,3] y = [4] print(x+y) [1, 2, 3, 4] # * 运算 x = [1,2,3] print(x*2) [1, 2, 3, 1, 2, 3] 删除pop()x = [1,2,3,4] y = x.pop() print(y) print(x) 4 [1, 2, 3] # 还可以指定索引弹出: x = [1,2,3,4] y = x.pop(2) print(y) print(x) 3 [1, 2, 4] remove()x = [1,2,3,4] x.remove(3) print(x) x.remove(3) # 注意，remove参数必须在列表中存在，否则会报错。 [1, 2, 4] --------------------------------------------------------------------------- ValueError Traceback (most recent call last) /var/folders/1j/k13fttf13b5d6j8_m4q12rgr0000gn/T/ipykernel_25574/2407277402.py in &lt;module&gt; 3 print(x) 4 ----&gt; 5 x.remove(3) 6 # 注意，remove参数必须在列表中存在，否则会报错。 ValueError: list.remove(x): x not in list 清空列表：clear()x = [1,2,3] x.clear() print(x) [] delx = [1,2,3,4] del x[1] print(x) [1, 3, 4] 访问和计数count( )计次x = [1,2,1,3,1,4] y = x.count(1) print(y) 3 index() 返回下标位置x = x = [1,2,1,3,1,4] y = x.index(1) print(y)#注意index是输出第一次出现的下标 0 in 判断是否存在x = [1,2,3,4] result1 = 5 in x result2 = 3 in x print(result1) print(result2) False True 排序sort() 默认升序aList = [3, 4, 15, 11, 9, 17, 13, 6, 7, 5] aList.sort() #默认是升序排序 print(aList) aList.sort(reverse = True) #降序排序 print(aList) [3, 4, 5, 6, 7, 9, 11, 13, 15, 17] [17, 15, 13, 11, 9, 7, 6, 5, 4, 3] shuffle 随机降序import random aList = [3, 4, 5, 6, 7, 9, 11, 13, 15, 17] random.shuffle(aList) #随机降序 print(aList) [3, 4, 7, 11, 15, 17, 9, 6, 13, 5] reverse()逆排序x = [3, 4, 15, 11, 9, 17, 13, 6, 7, 5] x.reverse() print(x) [5, 7, 6, 13, 17, 9, 11, 15, 4, 3] sorted()x = [6,4,2,4,1] sorted(x) #升序排序 [1,2,4,4,6] sorted(aList,reverse = True) #降序排序 [6,4,4,2,1] x File \"/var/folders/1j/k13fttf13b5d6j8_m4q12rgr0000gn/T/ipykernel_25574/3513965143.py\", line 1 &gt;&gt;&gt;x = [6,4,2,4,1] ^ SyntaxError: invalid syntax 常用内置函数len() 返回列表长度x = [1,2,3,4,5] len(x) #注意参数是所需列表 5 max() 和 min()x = [1,3,5] print(max(x)) print(min(x)) 5 1 zip() 将多个列表打包成元组x = [1,3,5] y = [2,4,6] zipped = zip(x,y) zipped_list = list(zipped)#注意需要把zip文件类型进行转换 print(zipped_list) [(1, 2), (3, 4), (5, 6)] enumberate() 枚举（生成的是元组列表，每个元组是下表和元素值组成）a = 'a,b,c,d,e,f' for an in enumerate(a): print(an) (0, 'a') (1, ',') (2, 'b') (3, ',') (4, 'c') (5, ',') (6, 'd') (7, ',') (8, 'e') (9, ',') (10, 'f') 遍历列表的三种方式：a = ['a','b','c','d','e','f'] for i in a: print(i) for i in range(len(a)): print(i,a[i]) for i,ele in enumerate(a): print(i,ele) 列表推导式：利用循环生成所需列表list = [i for i in range(1,100,2)] print(list) [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99] 应用：嵌套列表的平铺x = [[1,2,3],[4,5,6],[7,8,9]] x_flatted = [bn for an in x for bn in an] print(x_flatted) #等效写法： for an in x: for bn in an: x_flatted.append(bn) [1, 2, 3, 4, 5, 6, 7, 8, 9] 应用：过滤不符合条件的元素：aList = [-1,-4,6,7.5,-2.3,9,-11] filted = [i for i in aList if i&gt;0] print(filted) [6, 7.5, 9] 搭配元组使用 list = [(x, y) for x in [1, 2, 3] for y in [3, 1, 4] if x != y] print(list) [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)] 练习： 写一个循环，不断的问用户想买什么，用户选择一个商品编号，就把对应的商品添加到购物车里，最终用户输入q退出时，打印购物车里的商品列表 item_list = [['iphone',1],['xiaomi',2],['huawei',3]] item_selected = [] item_flag = 0 while item_flag != \"q\": item_flag = input(\"What do you want? Please enter the item number you need.\") for item in item_list: for tag in item: if type(tag) == int and str(tag) == item_flag: item_selected.append(item) print(item_selected) # 使用字典： item_selected = [] item_dictionary = {'iphone':1,'xiaomi':2,'huawei':3} item_flag = 0 while item_flag != \"q\": item_flag = input(\"What do you want? Please enter the item number you need.\") for item_name,item_price in item_dictionary.items():#单独使用.values()，也可以 if str(item_price) == item_flag: item_selected.append(item_name) print(item_selected) # 可以添加一些限制条件让程序更强壮 products = [['iphone',6888],['三星',3000],['小米',2500]] shopping_car = [] flag = True while flag: print(\"******商品列表******\") for index,i in enumerate(products): print(\"%s. %s| %s\" %(index,i[0],i[1])) choice = input(\"请输入您想购买的商品的编号：\") if choice.isdigit():#isdigit()判断变量是什么类型 choice = int(choice) if choice&gt;=0 and choice&lt;len(products): shopping_car.append(products[choice]) print(\"已经将%s加入购物车\" %(products[choice])) else: print(\"该商品不存在\") elif choice == \"q\": if len(shopping_car)&gt;0: print(\"您打算购买以下商品：\") for index,i in enumerate(shopping_car): print(\"%s. %s| %s\" %(index,i[0],i[1])) else: print(\"您的购物车中没有添加商品\") flag = False What do you want? Please enter the item number you need.1 What do you want? Please enter the item number you need.2 What do you want? Please enter the item number you need.q ['iphone', 'xiaomi'] 列表的切片操作：格式：li[start : end : step]，注意：都是左闭右开，切的时候按照步长方向必须有区间 colors=[\"red\",\"blue\",\"green\"] for i in range(0,3): print(colors[i]) 0 red 1 blue 2 green li=[\"A\",\"B\",\"C\",\"D\"] print(li[0:3]) #起点的0索引可以省略，li[:3] print(li[2: ] ) #省略end，则切到末尾 print(li[1:3] ) print(li[0::2]) #从li[0]到li[3],设定步长为2。 ['A', 'B', 'C'] ['C', 'D'] ['B', 'C'] ['A', 'C'] 反向索引： 不知道什么时候好用li=[\"A\",\"B\",\"C\",\"D\"] t=li[-1:-3:-1] print(t) t=li[-1:1:-1] print(t) t=li[3:1:-1] print(t) t=li[3:-3:-1] print(t) ['D', 'C'] ['D', 'C'] ['D', 'C'] ['D', 'C'] 使用切片原地修改内容：list = [1,2,3] list[len(list):] = [4] print(list) [1, 2, 3, 4] list = [1,2,3] for i in range(0,len(list)): list[i] += 1 print(list) [2, 3, 4] a = [1,2,3,4,5] a[:2] = [6,7,8]#甚至元素个数可以不一样 print(a) a[:3] = [] print(a) [6, 7, 8, 3, 4, 5] [3, 4, 5] **小技巧：切片配合del a = [1,2,3,4,5,6,7,8,9] del a[::2] print(a) [2, 4, 6, 8] 切片返回的是列表元素的浅复制a = [3,5,7] b = a #a对b直接赋值，本质上就是两个指针指向同一个地址 b[1] = 8 print(a) # 注意：改变b[1],a同时也变化，因为a，b本质上都是指针，都指向同一个地址。 print(id(a)) print(id(b)) [3, 8, 7] 140327721832256 140327721832256 a = [3,5,7] b = a[:] #使用切片赋值，是重开了新的内存，在内存写入相同的数值。并不是同一个储存空间。 print(a == b) print(a is b) b[1] = 8 print(a) print(b) True False [3, 5, 7] [3, 8, 7] 元组元组与列表：区别 元组中的数据一旦定义就不允许更改。 元组没有append()、extend()和insert()等方法，无法向元组中添加元素。 元组没有remove()或pop()方法，也无法对元组元素进行del操作，不能从元组中删除元素。 从效果上看，tuple( )冻结列表，而list( )融化元组。 元组优点 元组的速度比列表更快。 元组对不需要改变的数据进行“写保护”将使得代码更加安全。 元组可用作字典键（特别是包含字符串、数值和其它元组这样的不可变数据的元组）。元组有时还作为函数的返回值返回（返回多个值）。 元组的创建x = (3) print(type(x)) x = (3,) print(type(x)) # 注意：数据类型不一样 &lt;class 'int'&gt; &lt;class 'tuple'&gt; 创建空元组的方法： x = tuple() 元组的转换 tuple() # 参数可以是列表，可以是字符串","categories":[{"name":"Summerschool","slug":"Summerschool","permalink":"https://www.thripear.space/categories/Summerschool/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.thripear.space/tags/Python/"}],"author":"Oliver"},{"title":"Summerschool Python class1","slug":"Summerschool_Python1","date":"2023-06-19T03:25:00.000Z","updated":"2023-06-20T03:08:08.852Z","comments":true,"path":"posts/f2727548.html","link":"","permalink":"https://www.thripear.space/posts/f2727548.html","excerpt":"","text":"Summerschool class1列表列表长度可变，可以包含 不同的 数据类型，列表本质上储存的是对象地址，各种数据类型对象化了。 a = [],这个列表虽然是空的，它自己带这个列表的初始地址。 访问a = [1,2,3,4] print(a[-1]) # 使用负数返回列表倒数 4 插入a = [1,3,4] a.append(2) print(a) b = [1,3,4] b.insert(1,2) print(b) #注意append是添加到末尾 #insert(下标，元素)，插入在指定下标之后 [1, 3, 4, 2] [1, 2, 3, 4] a = [1,2] b = [3,4] a.extend(b) print(a) [1, 2, 3, 4] a = [1,2] b = [3,4] print(a+b) print(a*2) [1, 2, 3, 4] [1, 2, 1, 2] 删除a = [1,2,3,4] del a[1] print(a) # del(列表[数组下标]) [1, 3, 4] a = [1,2,3,4] a.pop() print(a) [1, 2, 3] b = [1,2,3,4] c = b.pop(2) print(c) print(b) 3 [1, 2, 4] a = [1,2,3,4] a.remove(2) print(a) #使用remove去除指定数值 [1, 3, 4] 排序a = [1,2,3,4] a.sort() print(a) a.sort(reverse = True) print(a) [1, 2, 3, 4] [4, 3, 2, 1] a = [4,2,3,1] print(sorted(a)) print(a) #sorted(列表)不改变列表顺序，临时排序 [1, 2, 3, 4] [4, 2, 3, 1] a = [4,2,3,1] a.reverse() print(a) [1, 3, 2, 4] 获得列表长度a = [999,998,993] print(len(a)) 3 计次a = [1,1,12] a.count(1) 2 循环for i in 3 [1, 2, 3, 4] [1, 2, 3, 4] [1, 2, 3, 4] [1, 2, 3, 4] 字符串处理print(\"a\"*50) aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 输入x = input(\"清输入：\") print(x) 清输入：3 3 查看类型x = 1 print(type(x)) y = 0.23 print(type(y)) &lt;class 'int'&gt; &lt;class 'float'&gt; 变量输出%s %d %f %% name = \"oliver\" print(\"my name is %s\"% name) num = 20 print(\"my age is: %d\"%num) class1 = \"math\" class2 = \"aria\" print(\"my favorate is %s and %s\"%(class1,class2)) my name is oliver my age is: 20 my favorate is math and aria format:用{}替换%name = 'han' code = \"c++\" str = \"{} said: good, {} is his fav\".format(name,code) print(str) # format中相当于一个元组，可以用下标： str = \"{1} and {0}\".format(\"a\",\"b\") print(str) han said: good, c++ is his fav b and a -f使用a = '1' b = '2' print(f'{a} + {a} = {b}') 1 + 1 = 2 变量命名：小驼峰/大驼峰 运算符// 取整除 % 取余数 ** 幂 9 // 2 4 条件语句 注意else if是 elif 循环pass是空语句，保持结构完整性 range函数用的很多： range(起点，终点，步长) for value in range(1,6): print(value,end = \" \") print(\"\\n\") for value in range(1,6,2): print(value,end = \" \") 1 2 3 4 5 1 3 5 注意！range右侧是开括号，取不到 随机数import random random.radient(a,b)#返回a,b之间的随机值","categories":[{"name":"Summerschool","slug":"Summerschool","permalink":"https://www.thripear.space/categories/Summerschool/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.thripear.space/tags/Python/"}],"author":"Oliver"},{"title":"卷积神经网络基础","slug":"卷积神经网络基础","date":"2023-04-14T03:48:00.000Z","updated":"2023-04-14T11:51:53.083Z","comments":true,"path":"posts/dd983220.html","link":"","permalink":"https://www.thripear.space/posts/dd983220.html","excerpt":"","text":"1.1 卷积神经网络基础CNN 卷积神经网络：包含卷积层的网络 全连接层：由神经元连接而成 卷积层：一个滑动窗口在图像上滑动并计算计算利用卷积核，将卷积核覆盖到图像上，再将卷积核上面的值与图像层相乘，最后相加得到该区域的值。 不断滑动，得到各个位置的卷积值 特性：1.具有局部感知机制 2.权值共享 对多维的矩阵进行卷积操作： 条件：1.输入特征矩阵深度与卷积核深度保持一致 2. 卷积完输出的特征矩阵（深度）与卷积核个数相同 计算：各个深度的卷积层相同位置处，卷积出来的值相加，最后各个深度卷完成一层了 当然卷积核不唯一，卷完之后拼接在一起 具体计算细节问题： 如何带上偏移量计算？ 当前卷积核输出的卷积矩阵，减去偏移量bias 加上激活函数该如何计算？常用激活函数： sigmoid激活函数 f(x) = \\frac{1}{1+e^{-x}} relu激活函数 f(x) = Max(0,x) 因为计算过程是一个线性过程，如果想要解决非线性问题，就需要引入非线性因素。 3.越界问题：矩阵经过卷积操作后的尺寸由以下几个因数决定： &lt;1&gt;输入图片的大小 W x W &lt;2&gt;Filter大小F x F （卷积核滑动窗口大小） &lt;3&gt;步长S &lt;4&gt;padding的像素数 (补零的像素数) P 经过卷积后的矩阵尺寸大小计算公式为： N = \\frac{W-F+2P}{S+1}池化层：对特征图进行稀疏处理，减少数据运算量MaxPooling下采样层 AveragePooling下采样层 ·只改变特征矩阵的大小，不改变深度 ·一般池化核边长和步长相同 1.2 卷积神经网络基础补充误差的计算 当前该节点的输出为： out = \\sigma(x_1\\times w_{11}^{(1)}+x_2\\times w_{21}^{(1)}+b_1^{(1)})w指权重，b为偏置，x1,x2等为上一个神经元的输出，若上一层为输出层就直接输入数据 上标（1）指当前处于哪一层 下表第一个数字是上一层第几个神经元，第二个数字是本层第几个神经元 最后一层的激活函数是softmax softmax计算过程： o_i = \\frac{e^{y_i}}{\\sum_{j}e^{y_j}}比如上图， o_1 = \\frac{e^{y_1}}{e^{y_1}+e^{y_2}} o_2 = \\frac{e^{y_2}}{e^{y_1}+e^{y_2}}误差计算方法一：交叉熵损失根据问题种类，有两种： 1.针对多分类问题（softmax输出，所有输出概率和为1，分类之间没有包含关系） H = -\\sum_i o_ i^* \\times log(o_i)2.针对二分类问题 (sigmoid输出，每个输出节点之间互不相干,分类之间有包含关系) H = -\\frac{1}{N}\\sum_{i=1}^N[o_i^*\\times logo_i+(1-o_i^*)\\times log(1-o_i)]上述公式中， H（Loss）为损失，o^*_i为真实值标签，o_i为预测值，默认log以e为底是ln误差的反向传播 最后带入得到： \\frac{\\part Loss}{\\part w_{11}^{(2)}} = (o_2^*\\times o_1-o_1^* \\times o_2)\\times a_1根据误差进行权重的更新 w_{11}^{(2)}(new) = w_{11}^{(2)}(old)-learing_{rate}\\times \\frac{\\part Loss}{\\part w_{11}^{(2)}}(gradient)问题：当分批次训练时，批次的损失梯度和整体sample的方向不一样 所以需要优化器： SGD优化器： w_{t+1} = w_t-\\alpha \\times g(w_t) \\alpha为学习率，g(w_t)为t时刻对参数w_t的损失梯度 优化器的缺点： 1 容易受样本噪声的影响 2 可能陷入局部最优解 SGD+Momentum优化器： v_t = \\eta \\times v_{t-1} + \\alpha \\times g(w_t) w_{t+1} = w_t - v_t \\alpha为学习率，g(w_t)为t时刻对参数w_t的损失梯度，\\eta(0.9)为动量系数。 Adagrad优化器（自适应学习率） s_t = s_{t-1}+g(w_t)^2 w_{t+1} = w_t - \\frac {\\alpha}{\\sqrt{s_t+\\epsilon}}*g(w_t) \\alpha 为学习率，g(w_t)为t时刻对参数w_t的损失梯度，\\epsilon(10^{-7}为防止分母为0的小数)缺点：学习率下降太快可能还没收敛就停止训练","categories":[{"name":"卷积神经网络","slug":"卷积神经网络","permalink":"https://www.thripear.space/categories/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://www.thripear.space/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"计算机视觉","slug":"计算机视觉","permalink":"https://www.thripear.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"}],"author":"Oliver"},{"title":"AlexNet代码详解","slug":"alexnet","date":"2023-04-13T03:48:00.000Z","updated":"2023-04-14T10:49:58.026Z","comments":true,"path":"posts/37003b0.html","link":"","permalink":"https://www.thripear.space/posts/37003b0.html","excerpt":"","text":"\\一、开发背景**AlexNet由Hinton和他的学生Alex Krizhevsky设计，模型名字来源于论文第一作者的姓名Alex。该模型以很大的优势获得了2012年ISLVRC竞赛的冠军网络，分类准确率由传统的 70%+提升到 80%+，自那年之后，深度学习开始迅速发展。 ImageNet是一个在2009年创建的图像数据集，从2010年开始到2017年举办了七届的ImageNet 挑战赛——ImageNet Large Scale Visual Recognition ChallengeI (LSVRC)，在这个挑战赛上诞生了AlexNet、ZFNet、OverFeat、VGG、Inception、ResNet、WideResNet、FractalNet、DenseNet、ResNeXt、DPN、SENet 等经典模型。 二、网络结构Alexnet模型为8层深度网络，由5个卷积层和3个全连接层构成，不计LRN层和池化层。AlexNet 跟 LeNet 结构类似，但使用了更多的卷积层和更大的参数空间来拟合大规模数据集 ImageNet。它是浅层神经网络和深度神经网络的分界线，如下图所示： 网络详解：AlexNet网络结构详解（含各层维度大小计算过程）与PyTorch实现 三、模型特点 使用CUDA加速深度卷积网络的训练，利用GPU强大的并行计算能力，处理神经网络训练时大量的矩阵运算； 使用大数据训练，是百万级ImageNet图像数据，提升算法的准确率，避免过拟合； 使用ReLU作为激活函数，解决了SIgmoid在网络较深时的梯度消失问题，使收敛更快； 使用随机丢弃技术（dropout）以0.5的概率选择性地将隐藏层神经元的输出设置为零，以这种方式“dropped out”的神经元既不参与前向传播，也不参与反向传播，避免模型的过拟合； 重叠最大池化（overlapping max pooling），池化的步长小于核尺寸，使得输出之间会有重叠和覆盖，提升了特征的丰富性，并且避免平均池化的模糊化效果； 使用 LRN 局部响应归一化（Local Response Normalization）层，对局部神经元的活动创建竞争机制，使得响应较大的值变得相对更大，并抑制其他反馈较小的神经元，增强了模型的泛化能力，使准确率更高； 进行数据增强，随机从256256的原始图像中截取224224大小的区域（以及水平翻转的镜像），相当于增强了（256-224）（256-224）2=2048倍的数据量，减轻过拟合，提升泛化能力。 为什么Dropout有效？ Dropout背后理念和集成模型很相似。在Drpout层，不同的神经元组合被关闭，这代表了一种不同的结构，所有这些不同的结构使用一个的子数据集并行地带权重训练，而权重总和为1。如果Dropout层有 n 个神经元，那么会形成 2n 个不同的子结构。在预测时，相当于集成这些模型并取均值。这种结构化的模型正则化技术有利于避免过拟合。Dropout有效的另外一个视点是：由于神经元是随机选择的，所以可以减少神经元之间的相互依赖，从而确保提取出相互独立的重要特征。 四、代码实现 model.py ：定义AlexNet网络模型 train.py：加载数据集并训练，计算loss和accuracy，保存训练好的网络参数 predict.py：用自己的数据集进行分类测试 spilit_data.py：划分给定的数据集为训练集和测试集 注意：代码实现没有还原两个小型GPU同时运算的设计特点，而是在一个模型中运行 \\1. model.py**# 导入pytorch库 import torch # 导入torch.nn模块 from torch import nn # nn.functional：(一般引入后改名为F)有各种功能组件的函数实现，如：F.conv2d import torch.nn.functional as F # 定义AlexNet网络模型 # MyLeNet5（子类）继承nn.Module（父类） class MyAlexNet(nn.Module): # 子类继承中重新定义Module类的__init__()和forward()函数 # init()：进行初始化，申明模型中各层的定义 def __init__(self): # super：引入父类的初始化方法给子类进行初始化 super(MyAlexNet, self).__init__() # 卷积层，输入大小为224*224，输出大小为55*55，输入通道为3，输出为96，卷积核为11，步长为4 self.c1 = nn.Conv2d(in_channels=3, out_channels=96, kernel_size=11, stride=4, padding=2) # 使用ReLU作为激活函数 self.ReLU = nn.ReLU() # MaxPool2d：最大池化操作 # 最大池化层，输入大小为55*55，输出大小为27*27，输入通道为96，输出为96，池化核为3，步长为2 self.s1 = nn.MaxPool2d(kernel_size=3, stride=2) # 卷积层，输入大小为27*27，输出大小为27*27，输入通道为96，输出为256，卷积核为5，扩充边缘为2，步长为1 self.c2 = nn.Conv2d(in_channels=96, out_channels=256, kernel_size=5, stride=1, padding=2) # 最大池化层，输入大小为27*27，输出大小为13*13，输入通道为256，输出为256，池化核为3，步长为2 self.s2 = nn.MaxPool2d(kernel_size=3, stride=2) # 卷积层，输入大小为13*13，输出大小为13*13，输入通道为256，输出为384，卷积核为3，扩充边缘为1，步长为1 self.c3 = nn.Conv2d(in_channels=256, out_channels=384, kernel_size=3, stride=1, padding=1) # 卷积层，输入大小为13*13，输出大小为13*13，输入通道为384，输出为384，卷积核为3，扩充边缘为1，步长为1 self.c4 = nn.Conv2d(in_channels=384, out_channels=384, kernel_size=3, stride=1, padding=1) # 卷积层，输入大小为13*13，输出大小为13*13，输入通道为384，输出为256，卷积核为3，扩充边缘为1，步长为1 self.c5 = nn.Conv2d(in_channels=384, out_channels=256, kernel_size=3, stride=1, padding=1) # 最大池化层，输入大小为13*13，输出大小为6*6，输入通道为256，输出为256，池化核为3，步长为2 self.s5 = nn.MaxPool2d(kernel_size=3, stride=2) # Flatten()：将张量（多维数组）平坦化处理，神经网络中第0维表示的是batch_size，所以Flatten()默认从第二维开始平坦化 self.flatten = nn.Flatten() # 全连接层 # Linear（in_features，out_features） # in_features指的是[batch_size, size]中的size,即样本的大小 # out_features指的是[batch_size，output_size]中的output_size，样本输出的维度大小，也代表了该全连接层的神经元个数 self.f6 = nn.Linear(6*6*256, 4096) self.f7 = nn.Linear(4096, 4096) # 全连接层&amp;softmax self.f8 = nn.Linear(4096, 1000) self.f9 = nn.Linear(1000, 2) # forward()：定义前向传播过程,描述了各层之间的连接关系 def forward(self, x): x = self.ReLU(self.c1(x)) x = self.s1(x) x = self.ReLU(self.c2(x)) x = self.s2(x) x = self.ReLU(self.c3(x)) x = self.ReLU(self.c4(x)) x = self.ReLU(self.c5(x)) x = self.s5(x) x = self.flatten(x) x = self.f6(x) # Dropout：随机地将输入中50%的神经元激活设为0，即去掉了一些神经节点，防止过拟合 # “失活的”神经元不再进行前向传播并且不参与反向传播，这个技术减少了复杂的神经元之间的相互影响 x = F.dropout(x, p=0.5) x = self.f7(x) x = F.dropout(x, p=0.5) x = self.f8(x) x = F.dropout(x, p=0.5) x = self.f9(x) return x # 每个python模块（python文件）都包含内置的变量 __name__，当该模块被直接执行的时候，__name__ 等于文件名（包含后缀 .py ） # 如果该模块 import 到其他模块中，则该模块的 __name__ 等于模块名称（不包含后缀.py） # “__main__” 始终指当前执行模块的名称（包含后缀.py） # if确保只有单独运行该模块时，此表达式才成立，才可以进入此判断语法，执行其中的测试代码，反之不行 if __name__ == '__main__': # rand：返回一个张量，包含了从区间[0, 1)的均匀分布中抽取的一组随机数，此处为四维张量 x = torch.rand([1, 3, 224, 224]) # 模型实例化 model = MyAlexNet() y = model(x) 2. train.pyimport torch from torch import nn from model import MyAlexNet from torch.optim import lr_scheduler from torchvision import transforms from torchvision.datasets import ImageFolder from torch.utils.data import DataLoader import os import matplotlib.pyplot as plt # 解决中文显示问题 # 运行配置参数中的字体（font）为黑体（SimHei） plt.rcParams['font.sans-serif'] = ['simHei'] # 运行配置参数总的轴（axes）正常显示正负号（minus） plt.rcParams['axes.unicode_minus'] = False ROOT_TRAIN = 'D:/pycharm/AlexNet/data/train' ROOT_TEST = 'D:/pycharm/AlexNet/data/val' # 将图像的像素值归一化到[-1,1]之间 normalize = transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5]) # Compose()：将多个transforms的操作整合在一起 train_transform = transforms.Compose([ # Resize()：把给定的图像随机裁剪到指定尺寸 transforms.Resize((224, 224)), # RandomVerticalFlip()：以0.5的概率竖直翻转给定的PIL图像 transforms.RandomVerticalFlip(), # ToTensor()：数据转化为Tensor格式 transforms.ToTensor(), normalize]) val_transform = transforms.Compose([ transforms.Resize((224, 224)), transforms.ToTensor(), normalize]) # 加载训练数据集 # ImageFolder：假设所有的文件按文件夹保存，每个文件夹下存储同一个类别的图片，文件夹名为类名，其构造函数如下： # ImageFolder(root, transform=None, target_transform=None, loader=default_loader) # root：在root指定的路径下寻找图像，transform：对输入的图像进行的转换操作 train_dataset = ImageFolder(ROOT_TRAIN, transform=train_transform) # DataLoader：将读取的数据按照batch size大小封装给训练集 # dataset (Dataset)：加载数据的数据集 # batch_size (int, optional)：每个batch加载多少个样本(默认: 1) # shuffle (bool, optional)：设置为True时会在每个epoch重新打乱数据(默认: False) train_dataloader = DataLoader(train_dataset, batch_size=32, shuffle=True) # 加载训练数据集 val_dataset = ImageFolder(ROOT_TEST, transform=val_transform) val_dataloader = DataLoader(val_dataset, batch_size=32, shuffle=True) # 如果有NVIDA显卡，可以转到GPU训练，否则用CPU device = 'cuda' if torch.cuda.is_available() else 'cpu' # 模型实例化，将模型转到device model = MyAlexNet().to(device) # 定义损失函数（交叉熵损失） loss_fn = nn.CrossEntropyLoss() # 定义优化器(随机梯度下降法) # params(iterable)：要训练的参数，一般传入的是model.parameters() # lr(float)：learning_rate学习率，也就是步长 # momentum(float, 可选)：动量因子（默认：0），矫正优化率 optimizer = torch.optim.SGD(model.parameters(), lr=0.01, momentum=0.9) # 学习率每隔10轮变为原来的0.5 # StepLR：用于调整学习率，一般情况下会设置随着epoch的增大而逐渐减小学习率从而达到更好的训练效果 # optimizer （Optimizer）：更改学习率的优化器 # step_size（int）：每训练step_size个epoch，更新一次参数 # gamma（float）：更新lr的乘法因子 lr_scheduler = lr_scheduler.StepLR(optimizer, step_size=10, gamma=0.5) # 定义训练函数 def train(dataloader, model, loss_fn, optimizer): loss, current, n = 0.0, 0.0, 0 # dataloader: 传入数据（数据包括：训练数据和标签） # enumerate()：用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在for循环当中 # enumerate返回值有两个：一个是序号，一个是数据（包含训练数据和标签） # x：训练数据（inputs）(tensor类型的），y：标签（labels）(tensor类型） for batch, (x, y) in enumerate(dataloader): # 前向传播 image, y = x.to(device), y.to(device) # 计算训练值 output = model(image) # 计算观测值（label）与训练值的损失函数 cur_loss = loss_fn(output, y) # torch.max(input, dim)函数 # input是具体的tensor，dim是max函数索引的维度，0是每列的最大值，1是每行的最大值输出 # 函数会返回两个tensor，第一个tensor是每行的最大值；第二个tensor是每行最大值的索引 _, pred = torch.max(output, axis=1) # 计算每批次的准确率 # output.shape[0]为该批次的多少，output的一维长度 # torch.sum()对输入的tensor数据的某一维度求和 cur_acc = torch.sum(y == pred)/output.shape[0] # 反向传播 # 清空过往梯度 optimizer.zero_grad() # 反向传播，计算当前梯度 cur_loss.backward() # 根据梯度更新网络参数 optimizer.step() # item()：得到元素张量的元素值 loss += cur_loss.item() current += cur_acc.item() n = n + 1 train_loss = loss / n train_acc = current / n # 计算训练的错误率 print('train_loss==' + str(train_loss)) # 计算训练的准确率 print('train_acc' + str(train_acc)) return train_loss, train_acc # 定义验证函数 def val(dataloader, model, loss_fn): loss, current, n = 0.0, 0.0, 0 # eval()：如果模型中有Batch Normalization和Dropout，则不启用，以防改变权值 model.eval() with torch.no_grad(): for batch, (x, y) in enumerate(dataloader): # 前向传播 image, y = x.to(device), y.to(device) output = model(image) cur_loss = loss_fn(output, y) _, pred = torch.max(output, axis=1) cur_acc = torch.sum(y == pred)/output.shape[0] loss += cur_loss.item() current += cur_acc.item() n = n+1 val_loss = loss / n val_acc = current / n # 计算验证的错误率 print('val_loss=' + str(val_loss)) # 计算验证的准确率 print('val_acc=' + str(val_acc)) return val_loss, val_acc # 定义画图函数 # 错误率 def matplot_loss(train_loss, val_loss): # 参数label = ''传入字符串类型的值，也就是图例的名称 plt.plot(train_loss, label='train_loss') plt.plot(val_loss, label='val_loss') # loc代表了图例在整个坐标轴平面中的位置（一般选取'best'这个参数值） plt.legend(loc='best') plt.xlabel('loss') plt.ylabel('epoch') plt.title(\"训练集和验证集的loss值对比图\") plt.show() # 准确率 def matplot_acc(train_acc, val_acc): plt.plot(train_acc, label = 'train_acc') plt.plot(val_acc, label = 'val_acc') plt.legend(loc = 'best') plt.xlabel('acc') plt.ylabel('epoch') plt.title(\"训练集和验证集的acc值对比图\") plt.show() #开始训练 loss_train = [] acc_train = [] loss_val = [] acc_val = [] # 训练次数 epoch = 20 # 用于判断最佳模型 min_acc = 0 for t in range(epoch): lr_scheduler.step() print(f\"epoch{t+1}\\n----------\") # 训练模型 train_loss, train_acc = train(train_dataloader, model, loss_fn, optimizer) # 验证模型 val_loss, val_acc = val(val_dataloader, model, loss_fn) loss_train.append(train_loss) acc_train.append(train_acc) loss_val.append(val_loss) acc_val.append(val_acc) # 保存最好的模型权重 if val_acc &gt; min_acc: folder = 'save_model' # path.exists：判断括号里的文件是否存在的意思，括号内可以是文件路径，存在为True if not os.path.exists(folder): # os.mkdir() 方法用于以数字权限模式创建目录 os.mkdir('save_model') min_acc = val_acc print(f\"save best model，第{t+1}轮\") # torch.save(state, dir)：保存模型等相关参数，dir表示保存文件的路径+保存文件名 # model.state_dict()：返回的是一个OrderedDict，存储了网络结构的名字和对应的参数 torch.save(model.state_dict(), 'save_model/best_model.pth') # 保存最后一轮权重 if t == epoch-1: torch.save(model.state_dict(), 'save_model/best_model.pth') matplot_loss(loss_train, loss_val) matplot_acc(acc_train, acc_val) print('done') 3. predict.pyimport torch from model import MyAlexNet from torch.autograd import Variable from torchvision import transforms from torchvision.transforms import ToPILImage from torchvision.datasets import ImageFolder from torch.utils.data import DataLoader ROOT_TRAIN = 'D:/pycharm/AlexNet/data/train' ROOT_TEST = 'D:/pycharm/AlexNet/data/val' # 将图像的像素值归一化到[-1,1]之间 normalize = transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5]) val_transform = transforms.Compose([ transforms.Resize((224, 224)), transforms.ToTensor(), normalize ]) # 加载训练数据集 val_dataset = ImageFolder(ROOT_TEST, transform=val_transform) # 如果有NVIDA显卡，转到GPU训练，否则用CPU device = 'cuda' if torch.cuda.is_available() else 'cpu' # 模型实例化，将模型转到device model = MyAlexNet().to(device) # 加载train.py里训练好的模型 model.load_state_dict(torch.load(r'D:\\pycharm\\AlexNet\\save_model\\best_model.pth')) # 结果类型 classes = [ \"cat\", \"dog\" ] # 把Tensor转化为图片，方便可视化 show = ToPILImage() # 进入验证阶段 model.eval() for i in range(1): x, y = val_dataset[i][0], val_dataset[i][1] # show()：显示图片 show(x).show() # torch.unsqueeze(input, dim)，input(Tensor)：输入张量，dim (int)：插入维度的索引，最终扩展张量维度为4维 x = Variable(torch.unsqueeze(x, dim=0).float(), requires_grad=False).to(device) with torch.no_grad(): pred = model(x) # argmax(input)：返回指定维度最大值的序号 # 得到预测类别中最高的那一类，再把最高的这一类对应classes中的那一类 predicted, actual = classes[torch.argmax(pred[0])], classes[y] # 输出预测值与真实值 print(f'predicted:\"{predicted}\", actual:\"{actual}\"') 4. spilit_data.pyimport os from shutil import copy import random # 如果file不存在，创建file def mkfile(file): if not os.path.exists(file): os.makedirs(file) # 获取data文件夹下所有除.txt文件以外所有文件夹名（即需要分类的类名） # os.listdir()：用于返回指定的文件夹包含的文件或文件夹的名字的列表 file_path = 'D:/pycharm/AlexNet/data_name' pet_class = [cla for cla in os.listdir(file_path) if \".txt\" not in cla] # 创建训练集train文件夹，并由类名在其目录下创建子目录 mkfile('data/train') for cla in pet_class: mkfile('data/train/' + cla) # 创建验证集val文件夹，并由类名在其目录下创建子目录 mkfile('data/val') for cla in pet_class: mkfile('data/val/' + cla) # 划分比例，训练集 : 验证集 = 8 : 2 split_rate = 0.2 # 遍历所有类别的图像并按比例分成训练集和验证集 for cla in pet_class: # 某一类别的子目录 cla_path = file_path + '/' + cla + '/' # iamges列表存储了该目录下所有图像的名称 images = os.listdir(cla_path) num = len(images) # 从images列表中随机抽取k个图像名称 # random.sample：用于截取列表的指定长度的随机数，返回列表 # eval_index保存验证集val的图像名称 eval_index = random.sample(images, k=int(num * split_rate)) for index, image in enumerate(images): if image in eval_index: image_path = cla_path + image new_path = 'data/val/' + cla # copy()：将源文件的内容复制到目标文件或目录 copy(image_path, new_path) # 其余图像保存在训练集train中 else: image_path = cla_path + image new_path = 'data/train/' + cla copy(image_path, new_path) # '\\r' 回车，回到当前行的行首，而不会换到下一行，如果接着输出，本行以前的内容会被逐一覆盖 # &lt;模板字符串&gt;.format(&lt;逗号分隔的参数&gt;) # end=\"\"：将print自带的换行用end中指定的str代替 print(\"\\r[{}] processing [{}/{}]\".format(cla, index + 1, num), end=\"\") print() print(\"processing done!\")","categories":[{"name":"卷积神经网络","slug":"卷积神经网络","permalink":"https://www.thripear.space/categories/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://www.thripear.space/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"计算机视觉","slug":"计算机视觉","permalink":"https://www.thripear.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"}],"author":"Oliver"},{"title":"微信小程序编写课程笔记","slug":"微信小程序编写","date":"2023-01-31T13:05:00.000Z","updated":"2023-04-03T04:53:49.479Z","comments":true,"path":"posts/1b52ac91.html","link":"","permalink":"https://www.thripear.space/posts/1b52ac91.html","excerpt":"","text":"微信小程序编写框架结构app部分小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。 一个小程序主体部分由三个文件组成，必须放在项目的根目录，如下： 文件 必需 作用 app.js 是 小程序逻辑 app.json 是 小程序公共配置 app.wxss 否 小程序公共样式表 app.json用 对象:字符串数组 储存 用户可能访问的路径。(注意是相对于app.json这个文件的路径。) \"pages\":[\"pages/about/about\",\"pages/selfpage/selfpage\"] 注意这样写先加载about，再加载selfpage app.json写全局配置 详细见：https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html pages部分一个page就是一个页面，由四个文件组成，分别是： 文件类型 必需 作用 js 是 页面逻辑 wxml 是 页面结构 json 否 页面配置 wxss 否 页面样式表 页面.js中写页面对象 页面.wxml添加组件（内容），可调用wxml中的样式规则。 页面.json是对整个页面底部及导航栏进行编辑。 （详细配置可见https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/page.html 页面.wxml中写组件的详细参数（字体大小，位置等等）,用样式规则封装。 所以page文件夹中每一个子文件夹就是一个page，都有四个文件， app在根目录。 内容编写页面组件（元素）：wxml&lt;text class = \"info\" id=\"zbc\" style = \"\" bindtap=\"f0\" hidden=\"\" data-user-name=\"user\"&gt;Hello world &lt;/text&gt; class 引用配置类 bindtap = \"事件处理函数\" 将该组件与事件处理函数绑定。 hidden 设定是否隐藏 data- 设定组件自定义的数据，封装在事件对象中，在事件发生的时候传递数据给 事件处理函数。 &lt;image src=\"图片地址\"&gt;&lt;/image&gt; 如果是本地图片需要放在小程序的文件夹里面。新建一个images，和pages文件夹并列。 wxml是微信的标签语法，和html类似。 组件类别由两个&lt;&gt;封装，最后一个加/。 第一个&lt;&gt;中可以写组件的参数。 样式控制为了让一些组件使用相同的配置类，使用view进行组件划分 (和html的div作用相同) 。 &lt;view&gt; &lt;image src=\"http://oliverhangleblog.oss-cn-hangzhou.aliyuncs.com/img/avatar.jpg\"&gt;&lt;/image&gt; &lt;text&gt;小狐狸的主页&lt;/text&gt; &lt;text&gt;小狐狸的网站：thripear.space&lt;/text&gt; &lt;/view&gt; view封装使用的配置写在第一个&lt;&gt;中， &lt;view class = \"配置名字\"&gt; ... &lt;/view&gt; 应用弹性盒子布局（各组件位置）传统方式：编写位置：页面.wxss .container { background-color: #eee //加个背景颜色 height: 100vh; //整个页面100%高度处 text-align: center } text { display: block;//一个文字组件一行 } image,text{ margin-bottom: 60px; }//图片从下到上去给60像素的间隔 border-radius: 50%; 图片圆形边框 问题： 1.赋值分散 2.严重依赖页面结构和实际内容大小 使用弹性盒子： .container { background-color: #eee ; height: 100vh; display: flex; //设置弹性盒子 flex-direction: column; //从上到下竖直分布 justify-content: space-around; //上下均匀分布 align-items: center; //中心分布 } 就算是新增组件也可以立刻分布，非常灵活。 把弹性盒子的设定封装在container中，每个页面都可以调用。 注意：container放在全局用（app.wxss），某个page的wxss中的东西不能给其他page用。 适应不同屏幕宽度引入新的长度单位：rpx 使用rpx，默认所有设备的屏幕高度为750rpx 通常使用iPhone6的屏幕进行设计 如果是100px，直接x2变200rpx。 使用导航连接：navigator组件注意：text中只能为纯文本 text和navigator是并列，不能包含。 Navigator的重要属性 open-type属性 &lt;navigator url=\"/pages/selfpage/selfpage\" style=\"display: inline;\" open-type=\"redirect\"&gt; url后面写跳转地址，style设置组件display为inline，不会被弹性盒子给分开。 opentype为redirect 进入页面后，左上角不会出现返回按钮。默认为navigate navigator可以使用text的一些设定。（比如我用了text的maintext封装） hover-class属性： 被选中是使用’中的’设定 &lt;navigator url=\"/pages/selfpage/selfpage\" style=\"display: inline;\" open-type=\"redirect\"&gt; 声明： 我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=48phd0m6k409","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://www.thripear.space/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://www.thripear.space/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"author":"Oliver"},{"title":"SQL理论课-Class 5","slug":"SQL_Class_5","date":"2022-12-04T07:00:00.000Z","updated":"2023-04-03T04:53:49.479Z","comments":true,"path":"posts/4be38134.html","link":"","permalink":"https://www.thripear.space/posts/4be38134.html","excerpt":"","text":"Class_5: 子查询2select ENAME from EMP where salary = some (select salary from EMP where EMPNO = 30) and deptno &lt;&gt; 30 判断子查询是否存在：exists 和 not exists（相关子查询）EXISTS用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回值True或False。 和 in\\not in 的区别：in 的子查询可以先执行，因为子查询和外部查询无关（无关子查询）exists 先执行外部查询，因为子查询内部与外部查询可能有关（比如where条件中使用外部查询的别名）— 注意：只要子查询能独立执行就是不相关。— 外查询表中有多少行，就执行多少次exists，每一行都去测试。— in 是子查询结束，进行筛选。 select name from student as s where not exists (select * --exists子查询的select后面属性可以随便写，因为exists只判断是否符合条件。 from takes as t where s.ID=t.ID and course_id='cd-347') -- 注意：not exists 不会受表中数据存在NULL的影响。 查找所有选了全部生物课的学生生物系的课 - 学生选的课 = 空，即子查询不会返回行。 — 判断条件：not exists (生物系的课 except 学生选的课) 练习：找出哪个部门包含了除了总经理以外的所有种类的职位select DEPTNO from EMP where not exists (select distinct job from EMP where MGR is not NULL) --所有除了总经理的职位 except (select distinct job from EMP a where emp.deptno = a.deptno)--减去部门包含的职位 -- 减去部门包含的职位这里，外面的emp.deptno = 里面a.deptno 说明子查询的职位对应部门，正在外部查询的部门 ​ 子查询可以出现在任何表出现的地方。比如说select, from，where，havingselect 里面可以相关，不相关子查询from 不相关子查询where 相关，不相关，标量子查询 标量子查询：子查询返回行数为1行：可以出现在任何 值出现的地方：值运算符 with 语句当子查询出现在from，可读性太差用with子句：（也是不相关子查询）with 表名(属性名1,属性名2) as 表 with 表1 select 属性 from 表2 where 小表和大表的条件 with 表1 由表1定义的表2 from 表1，表2 where 表1和表2条件 重点习题：1.谁的工资比自己部门的平均工资高-- from写法： select ename from emp a,(select AVG(sal) avgs,deptno from emp group by deptno) as b where a.DEPTNO=b.DEPTNO and a.sal&gt;b.avgs -- with写法： with avg_SAL(avgs,deptno) as (select avg(sal),deptno from EMP group by DEPTNO) select ENAME from EMP a,avg_SAL --这里EMP记为a和上面子查询区分开。 where a.DEPTNO = avg_SAL.DEPTNO and a.SAL &gt; avg_SAL.avgs -- where写法： select ename from emp a where a.sal &gt;(select avg(sal) from emp b where a.DEPTNO=b.DEPTNO) 2.(标量子查询) 查询每个员工的工资和平均工资的差，以及该部门有多少人。select empno,sal-(select avg(sal) from emp),(count(*) from emp b where a.deptno=b.deptno) from emp a","categories":[{"name":"SQL学习","slug":"SQL学习","permalink":"https://www.thripear.space/categories/SQL%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://www.thripear.space/tags/SQL/"},{"name":"理论","slug":"理论","permalink":"https://www.thripear.space/tags/%E7%90%86%E8%AE%BA/"}],"author":"Oliver"},{"title":"SQL理论课-Class 4","slug":"SQL_Class_4","date":"2022-12-02T07:00:00.000Z","updated":"2023-04-03T04:53:49.479Z","comments":true,"path":"posts/3ce4b1a2.html","link":"","permalink":"https://www.thripear.space/posts/3ce4b1a2.html","excerpt":"","text":"Class_4:嵌套子查询：（可以转换成表连接）-- 把查询语句嵌套在where筛选条件中： select ename from emp where hiredate &gt; (select hiredate from emp where ename = 'king') -- 里面这个子查询返回一行可以直接使用比较运算符，因为就这一个人这个名字 如果子查询可能返回多行？— 把运算符号换成in select name from student where ID in(筛选出来的很多行) 用 in 和 not in 查询是否存在于查询集合中：select ENAME,EMPTNO,SAL from EMP where DEPTNO in (select DEPTNO from DEPT where LOC = 'NewYork') select count(salary) from EMP where DEPTNO in (Select DEPTNO from EMP where ENAME = 'blake') 双嵌套：select * from EMP where DETPNO not in(Select DEPTNO from EMP where ENAME = 'blake') and JOB in (select JOB from EMP where DEPTNO in (Select DEPTNO from EMP where ENAME = 'blake') ) SOME 和 ALL：运算符+some：满足一个就行select name from instructor where salary &gt; some (select salary from instructor where dept_name='Biology') -- 查找出来老师只要工资 比生物系最起码一个老师的工资高就行。 运算符+all ：必须要全部满足才可以=all 和 in 不是一个概念，in 是满足一个&lt;&gt;some 和 not in 不是一个概念some=&lt;&gt;all 和 not in 一个概念=some 和 in 一个概念 = &lt;&gt; &gt;= &lt;= some in -- &gt;=min &lt;=max all -- not in &lt;=max &lt;=min select name from student where id &lt;&gt;all(select id from takes where course_id = 'cd=347') select DEPTNO,AVG(SAL) from EMP group by DEPTNO having AVG(SAL) &gt;ALL AVG(select SAL from EMP group by DEPTNO) select ENAME from EMP where EMPNO in (select MGR from EMP) -- 陷阱：如果是not in，一定要小心NULL，因为NULL运算完了什么也找不到。 -- 加一个 EMPNO is not NULL","categories":[{"name":"SQL学习","slug":"SQL学习","permalink":"https://www.thripear.space/categories/SQL%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://www.thripear.space/tags/SQL/"},{"name":"理论","slug":"理论","permalink":"https://www.thripear.space/tags/%E7%90%86%E8%AE%BA/"}],"author":"Oliver"},{"title":"SQL理论课-Class 3","slug":"SQL_Class_3","date":"2022-11-30T07:00:00.000Z","updated":"2023-04-03T04:53:49.478Z","comments":true,"path":"posts/a2802401.html","link":"","permalink":"https://www.thripear.space/posts/a2802401.html","excerpt":"","text":"Class_2复习select b.ENAME from EMP a,EMP b where a.mgr=b.empno select empno from emp where deptno = 20 intersect select empno from emp where deptno = 20 Class_3聚集函数 Aggregate Functionsavg min max sum count输入一个集合，输出一个值。 avg,sum #只能用于数值 min,max,count #可以用于除数值之外。 count #是用来计数的，非NULL记录+1，反之不积累。 #AVG例子： #注意：相同数据不去重复。 select avg(salary) from instructor where dept_name = 'Biology' #加distinct去重复： select 聚集函数(distinct 属性) 注意：select count (*) 里面不能使用 distinct distinct 在 max 和 min 中一样。 除了 count(*)外所有的聚集函数都忽略输入集合中的空值 如果输入的集合只有空值avg , max, min 返回空值count 输入空值，返回0 分组：举例：求多个系的工资平均值先按照系分成多个组，每个组求一个工资平均值 -- 注意：出现在select子句中但没有被聚集的属性必须出现在 group by 子句中 select 属性1，属性2，聚集函数(属性) from 表 group by 属性1，属性2（按照属性1，属性2分组） -- 注意：筛选条件：分组后写条件用having，不分组用where select 属性1，属性2，聚集函数(属性) from 表 group by 属性1，属性2（按照属性1，属性2分组） having 条件 这样先通过 having 过滤元组，然后再分组。 计算机操作顺序：From where Group BY Having Select Order Bya 练习题：select count(数字) from instructor 本质上就是数行数 select dept_name,max(budget) from department group by dept_name 课后练习： select course_id,count(ID) from takes group by course_id select ID,count(course_id) from takes group by ID having count(course_Id)&gt;=3","categories":[{"name":"SQL学习","slug":"SQL学习","permalink":"https://www.thripear.space/categories/SQL%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://www.thripear.space/tags/SQL/"},{"name":"理论","slug":"理论","permalink":"https://www.thripear.space/tags/%E7%90%86%E8%AE%BA/"}],"author":"Oliver"},{"title":"SQL理论课-Note 1_Revision","slug":"SQL_Class_1_revision","date":"2022-11-24T07:00:00.000Z","updated":"2023-04-03T04:53:49.478Z","comments":true,"path":"posts/2e1f9be4.html","link":"","permalink":"https://www.thripear.space/posts/2e1f9be4.html","excerpt":"","text":"Class_1 复习-len（） 函数返回字符串长度 -补充：关于distinct：一个select语句只能有一个distinct。-字符串输出：select，当里面有单引号的时候，单引号打成双引号，以免报错。 -between and 是闭区间 -where salary in (50000,60000) 这样写就是 salary = 50000 或者 salary = 60000 -not in 的话就是既不是50000又不是60000 -当想要把%当成普通字符串处理，写成\\%，\\定义转义字符 -order by 补充-order by 默认升序 -order by 属性1，属性2，先按照1排序，后按照2排序，属性可以不出现在该句select后。 -如果两个都想按照降序， order by 属性1 desc，属性2 desc -order by 聚集函数 -order by 数字：按照 表里面的第（数字）列的属性 进行排序-order by 3,4 按照第3，4列排序select name,salary*1.1 news,2,'DUT',len(name) from instructor Select distinct ID from instructor select upper ('a') select 'It''s right' select name ,salary,ID,dept_name from instructor where dept_name like 'p2%' escape '2' where salary not in (50000,60000) select * from instructor order by 3,4 select a.course_id,b.prereq_id from prereq a,prereq b where a.prereq_id=b.course_id select * from instructor a,instructor b where a.salary=b.salary and a.name&lt;&gt;b.name","categories":[{"name":"SQL学习","slug":"SQL学习","permalink":"https://www.thripear.space/categories/SQL%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://www.thripear.space/tags/SQL/"},{"name":"理论","slug":"理论","permalink":"https://www.thripear.space/tags/%E7%90%86%E8%AE%BA/"}],"author":"Oliver"},{"title":"SQL理论课-Class 2","slug":"SQL_Class_2","date":"2022-11-24T07:00:00.000Z","updated":"2023-04-03T04:53:49.478Z","comments":true,"path":"posts/d5871497.html","link":"","permalink":"https://www.thripear.space/posts/d5871497.html","excerpt":"","text":"Class_2 新课多表查询 - 从多个表里面查询信息语法： select 需要的属性 from 表1，表2 -输出是表1和表2的笛卡尔积，结果没有意义。因为我们想要的是信息能对得上的。-需要使用where进行限定。where 表1.属性 = 表2.属性（这里面的属性需要在两个表里面都一样）（这里的 表1.和 表2.不能省略。） 表的连接：把两个及以上的表连接在一起前提条件：有相同的属性（比如玉兰卡id和学号），当然可以有不同的属性。select dept_name from course,section where course.course_id = section.course_id and dept_name = 'Comp.Sci' select from 表1 join 表2 on 表1.属性 = 表2.属性 还可以写成这样。效率比较高 如果想要把三个以上的表连接：Select * From emp join dept on emp.dpetno = dept.deptno Where loc = 'new York' 自然连接：每一个相同属性列仅留下一个拷贝。也就是连接属性（比如两个表里面的id）只会留一个，from 表1 natural join 表2 on 条件 -自然连接有危险，当连接多个表的时候，可能会出现目标数据查询损失。筛选过度。自连接：自己和自己中的元素进行查询,关键在于更改名字select distinct T.name from instructor as T,instructor as S where T.salary &gt; S.salary and S.dept_name = 'Comp.Sci.' 集合运算：并集：union交集：intersect减法：except前提：两个集合数据类型要一样SQL的集合中没有重复元素，保留重复需要：union all,intersect all 和 except all语法： select 属性1 from 表1 where 条件1 集合运算符 select 属性2 from 表2 where 条件2 空值 NULL数值 + null, null &lt;&gt; null null = null 结果是 unknown所以选择值是unknown的： where 属性 is null 注意：空值参与排序。 unknown 和 true 的逻辑运算以及结果： OR: (unknown or true) = true, (unknown or false) = unknown (unknown or unknown) = unknown – AND: (true and unknown) = unknown, (false and unknown) = false, (unknown and unknown) = unknown – NOT: (not unknown) = unknown – “P is unknown” evaluates to true if predicate P evaluates to unknown 小练习： 查询先修课的先修课的名字（自连接） use university select distinct P.prereq_id from prereq as C,prereq as P where C.prereq_id = P.course_id 查询两个工资相等的老师 select distinct A.name,B.name from instructor as A,instructor as B where A.salary = B.salary and A.name &lt;&gt; B.name","categories":[{"name":"SQL学习","slug":"SQL学习","permalink":"https://www.thripear.space/categories/SQL%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://www.thripear.space/tags/SQL/"},{"name":"理论","slug":"理论","permalink":"https://www.thripear.space/tags/%E7%90%86%E8%AE%BA/"}],"author":"Oliver"},{"title":"数据库演习-Class3 用户交互的数据库处理","slug":"SQL上机演习笔记3","date":"2022-11-22T13:00:00.000Z","updated":"2023-04-03T04:50:54.348Z","comments":true,"path":"posts/ca7688ec.html","link":"","permalink":"https://www.thripear.space/posts/ca7688ec.html","excerpt":"","text":"用户交互的数据库处理ORM思想：Object Relation Model 对象关系模型，映射到持久层【数据库】，存在 1 对 1 的映射关系 库 项目 表 类 字段，列 成员属性 记录 对象 多表关联 【外键 — 主键】1：1 持有对方对象【属性】 多表关联 【外键 — 主键】1：N 持有对方对象的框架集合【属性】 中间映射表 一般无需创建实体类，需要操作【订单】也可以创建实体类 Card表写成类：import java.sql.Timestamp; public class Card { private Integer cid; private Double cmoney; private Integer csid;//外键 private Student student; //多表联查，student中的sid主键是card的外键csid //存在一对一关系，持有对方对象,把csid查询出来对应的student对象封装到card的实例（对象）里面。 // 一对多，比如说一个学生对应多个老师，持有对方对象的集合 private Timestamp uptime; public static void main(String[] args){ //类需要具体实例化产生对象 } } Teacher表写成类import java.util.LinkedList; import java.util.List; public class Teacher { private Integer tid; private String tname; private Double salary; //一对多的映射，持有对方对象的集合 List&lt;Student&gt; students = new LinkedList&lt;Student&gt;();//这个用链表，方便插入 } Student表写成类import java.awt.*; import java.sql.Array; import java.sql.Timestamp; import java.util.ArrayList; import java.util.List; public class Student { private Integer sid;//主键 private String sname; private String phone; private Timestamp uptime; //1对多的映射，持有对方对象的集合 List&lt;Teacher&gt; teachers = new ArrayList&lt;Teacher&gt;();//list用u开头那个,用指针列表，方便查询 }","categories":[{"name":"SQL学习","slug":"SQL学习","permalink":"https://www.thripear.space/categories/SQL%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://www.thripear.space/tags/SQL/"},{"name":"上机","slug":"上机","permalink":"https://www.thripear.space/tags/%E4%B8%8A%E6%9C%BA/"}],"author":"Oliver"},{"title":"数据库演习-Class2 基础操作","slug":"SQL上机演习笔记2","date":"2022-11-22T13:00:00.000Z","updated":"2023-04-03T04:50:54.349Z","comments":true,"path":"posts/de4d37c.html","link":"","permalink":"https://www.thripear.space/posts/de4d37c.html","excerpt":"","text":"写SQL习惯注意：语法问题：1.执行语句后面用分号;2.设置主键外键的限制语句：用反引号！3.表最后一个设定没有符号原则问题：#原则1：语句不能依赖上下文，这样有就删除再创建，没有就创建。#原则2：删除时先删除外键所在的表中该元素，再删除主键所在表，#原则3：创建时先创建主键所在表2.1 创建数据库drop database if exists dlut002; create database if not exists dlut002; #原则1：语句不能依赖上下文，这样有就删除再创建，没有就创建。 使用数据库,后面的操作都在该数据库里面运行：use dlut002 ; 2.2 创建表：Create table 表名 #原则2：删除时先删除外键所在的表中该元素，再删除主键所在表，下面例子中要删除学生，先删除映射表中的学号，再删除主键（学生）中的学号 首先认识数据之间的关系：学号-学生—玉兰卡-卡号 玉兰卡的学号是外码，学生的学号是主码多对多的对应关系，比如学生对老师，老师对学生，在这个关系中间弄个中间表-叫映射表在这个例子中，映射表三个属性：编号，学号，教工号映射表里面挑的属性，主键和外键，主键独一无二区分（编号），学号教工号这样的叫外键上面的关系：ER图， 实体：矩形 虚体：椭圆形 #注意写表的语法，这样写才满足原则1。 drop table if exists mapper; drop table if exists card; drop table if exists teacher; drop table if exists student; #满足原则1，2 #先创建student是为了满足原则3 create table if not exists student( sid integer auto_increment comment '学号', sname varchar(30) not null comment '姓名', phone varchar(11) unique comment '电话', uptime timestamp default current_timestamp on update current_timestamp comment '更新时间', #current——timestamp，这个是当前时间戳，生成时插入系统时间,修改时再插入修改时的当时时间 primary key `s_pk` (`sid`) #主键设置放最后比较好，··是反向单引号，表示主键名字的！ #设定主键后，编译器默认主键不能为空，可以为null。注意：主键还不能重复。 )comment '学生表'; sid是行名字，当行号每多一行，自动增长sid。 数据表字段的设计：#1. 主键建议使用： 整数#2. 字段的约束【unique唯一，not null，default（默认值）】#3. ‘’ 单引号表示字符串 ！ ··是反向单引号，表示主键名字的#玉兰卡和学生一一对应，如何写约束关系？ create table if not exists card( cid integer auto_increment comment '卡号', cmoney double default 0.0 comment '余额', csid integer not null comment '学号', #如果csid写成sid，会导致查询sid时查询到两个表中的sid，产生歧义。这个是区分。 uptime timestamp default current_timestamp on update current_timestamp, primary key `c_pk`(`cid`), #约束条件在这里： constraint foreign key `c_to_s_fk` (`csid`) references `student`(`sid`) )comment '玉兰卡'; #删除记录： delete from card where cid =2; delete from card; #抹空数据 truncate card; #截断，抹空数据把自动增长的计数器也抹空 #构建教师表 create table if not exists teacher( tid integer auto_increment comment '教工号', tname varchar(30) not null comment '姓名', salary double default 0.0 comment '薪水', uptime timestamp default current_timestamp on update current_timestamp comment '更新时间', primary key `t_pk` (`tid`) )comment '教师表'; #构建映射表 create table if not exists mapper( mid integer auto_increment comment'映射号', msid integer not null comment'学号', mtid integer not null comment'教工号', uptime timestamp default current_timestamp on update current_timestamp comment'更新时间', primary key `m_pk`(`mid`), constraint foreign key `m_to_s_fk` (`msid`) references `student`(`sid`), constraint foreign key `m_to_t_fk` (`mtid`) references `teacher`(`tid`) )comment '学生和教师映射表_多对多'; 2.3增删改查应用程序猿 CRUD程序员 插入show tables; #列出当前数据库中所有的表 show create table mapper; #查创建组间时的SQL语句 #插入多行数据： insert into student(sname, phone) value ('zs','110'),('ls','120'),('ww','130'); 当要插入很大量数据，使用循环数据库里面的函数叫 存储过程delimiter $$ create procedure sp_bs(IN nums int)#声明储存过程这样写，注意形参的写法 BEGIN declare count int default 1; while count &lt;= nums do insert into student(sname,phone) values (concat('stu',count),concat('1',FLOOR(rand()*8999999999+1000000000))); #concat类似python的字符串f set count = count +1; end while; end$$ delimiter ; #调用存储过程 call sp_bs(9); #记不住存储过程去查一下 删除：delete from student #这样是把整个表里面数据都删除了 delete #只删除数据，不清空表结构。 删除某个特定行加 where truncate student truncate #截断表，清空数据，清空组件的属性信息。 set foreign_key_checks = false #暂停外键约束 truncate student #这样再清除就不会因为可能的外键约束清除失败。 set foreign_key_checks = true #清除完了再启动，要不然之前写的外键都没用了。 #这种编程叫做临界区编程，核心就是进来的时候设置条件，等操作完了再回复。 修改：修改逻辑是最复杂的。 注意： 一般修改不修改主键update student set sname = '张三',phone = '110119120'; 这样改不可以，相当于把表里面所有的 sname 和 phone 值全改了。 注意，phone之前设置为unique，所以这样修改会报错，因为会导致phone重复。 update 要跟上 where 条件： update student set name='zhanngsan',phone = '123456' where sid =1; 增加，修改和删除操作都是写入操作，意味着每条SQL语句都应该提交后生效，通常客户端中执行SQL默认每条语句后自动commit。 但是，自动提交不一定都是好的。 例子： delete from card where csid =4; #将sid为4的用户的玉兰卡注销 delete from student where sid =4; #先删除玉兰卡再删除学生。 为了删除这个学生，玉兰卡和学生信息必须都删除，不能只删除一个（执行第一句不执行第二句），这样导致信息不一致。 这个时候我们不让他自动提交，手工让它提交 begin delete from card where csid =4; #将sid为4的用户的玉兰卡注销 rollback; delete from student where sid =4; #先删除玉兰卡再删除学生。 commit ##这样写，两句里面哪一句出错,执行commit才能提交。 #还可以写成: set autocommit = false; delete from card where csid =4; #将sid为4的用户的玉兰卡注销 delete from student where sid =4;#先删除玉兰卡后再删除学生。 commit; set autocommit = true; 关于 begin 和 end procedure的那个begin，end相当于函数的花括号 数据库的begin（刚刚上面用的那一个），相当于启动事物， 比如说删除玉兰卡，再删除学生，最上面写一个begin，相当于认为它这个是一整个事物在进行 课后了解：ACID 查询：只读操作，无需commitselect 1+1; #生成一个Resultset 结果集【封装在内存】，其中 '1+1'作为列的别名，结果2成为结果集。 #Resultset是数据集，自迭代（像是指针原地址+位移） select @set; #查询变量 select * from student; #查询所有属性 数据查询过程中，先from，再投影【选择列】，再筛选whereselect sid,sname,phone,uptime from student as stu; 使用as起别名stu select sid,stu.sname,stu.phone,stu.uptime from student as stu where stu.sid&gt;1; 此时筛选是基于stu的sid，写成stu.sid比较好，但是因为sid只有一个，没写stu.也可以 如果是多表联查，比如说好几个表里面都有uptime，怎么样去区分呢。使用别名 多表连接查询： 连接类型：外连接（包含左右连接，写left和right都一样），内连接，自然连接 连接表数据量基数越少，查询效率越高。 select * from student,card; --形成了笛卡尔积，没有意义。 select * from student,card; left join card on student.sid = card.csid; 关键数据能对得上 select * from card as c left join student as s on c.csid = s.sid where s.uptime &gt; '2022-11-28' 联合查询uptime出现歧义，要指定，起别名更方便写， 而写的程序读的是结果集，你起的别名替代了原来的属性名字出现在结果集，后面的程序都是基于这个结果集查询的。 select * from card left join student on card.csid = student.sid where student.uptime &gt; '2022-11-28'","categories":[{"name":"SQL学习","slug":"SQL学习","permalink":"https://www.thripear.space/categories/SQL%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://www.thripear.space/tags/SQL/"},{"name":"上机","slug":"上机","permalink":"https://www.thripear.space/tags/%E4%B8%8A%E6%9C%BA/"}],"author":"Oliver"},{"title":"SQL理论课-Class 1","slug":"SQL-Class_1","date":"2022-11-19T07:00:00.000Z","updated":"2023-04-03T04:51:41.166Z","comments":true,"path":"posts/4c8e452d.html","link":"","permalink":"https://www.thripear.space/posts/4c8e452d.html","excerpt":"","text":"SQL-Note 1：—查询语句：select name（一个或多个属性） from instructor（一个或者多个表） where dept_name = 'cs'（满足条件） 练习：找到导师表中的系名select dept_name from instructor 找到表中所有属性：select * —但是这个在计算机中处理效率没有一个个都列出来的效率高。 from instructor 注意：select dept_name from instructor 当有多个导师属于一个系， 就会有重复。 --去重复： select distinct dept_name from instructor select distinct dept_name,id from instructor —像这样去重复多个元素，去除的是满足这两个条件出来的 重复行 —注意：distinct前面没有属性，只能后面添加一个或者多个属性 select distinct 主码 from 表 结果相当于没有distinct，但是效率会变低。 — select中的属性可以进行操作，还可以是函数调用。但是不会修改数据库中数据 select salary*1.1 from instructor 找导师工资出来，输出结果为1.1倍原工资数据 -- and or not 组成：复合条件 和 where 连用select salary&gt;8000 and dept_name = 'cs' —用as起名字：select salary*1.1 as over_salary from instructor —字符串处理函数：字符串1+字符串2 ：字符串拼接 upper(字符串) lower(字符串) —字符串匹配：-'Intro%' --寻找开头为Intro -'%abc%' --寻找中间含有abc -'___' --寻找三位长度 -'___%' --寻找至少三位 select name from instructor where name like '%abc%' --注意用like进行筛讯 \\定义转义字符—数字区间条件：between and：select name from instructor where salary between 9000 and 10000 —多条件匹配select name, course_id from instructor, teaches where (instructor.ID, dept_name) = (teaches.ID, ’Biology’); —排序：desc降序 asc升序– Example: order by name desc Can sort on multiple attributes – Example: order by dept_name, name --按照两个元素排序，字符串首字母。","categories":[{"name":"SQL学习","slug":"SQL学习","permalink":"https://www.thripear.space/categories/SQL%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://www.thripear.space/tags/SQL/"},{"name":"理论","slug":"理论","permalink":"https://www.thripear.space/tags/%E7%90%86%E8%AE%BA/"}],"author":"Oliver"},{"title":"数据库演习-Class1","slug":"SQL上机演习笔记1","date":"2022-11-19T07:00:00.000Z","updated":"2023-04-03T04:50:54.347Z","comments":true,"path":"posts/a8ebf2ca.html","link":"","permalink":"https://www.thripear.space/posts/a8ebf2ca.html","excerpt":"","text":"数据库演习成绩构成：20+80， 20最多3次点名，80大作业推荐实现：MySQL + Java时间： 20：20数据库结构化的数据存储方式。 sscanf,fprintf数据库类型：关系型，网状型。 文件型，内存型，服务型。MySQL：开源关系型数据库，典型的C/S结构， 【客户端/服务器】SQL基础Struct Query Language 结构化查询语句关系型数据库都支持SQL语句SQL属于高级语言：select name,password from user where sno=110增C删D改U查R1 数据库组件的增删改查【数据库database，表table，字段filed，主键primary key，外键foreign key】1.1 创建数据库 create [组件类型] 组件名；1.2 删除 drop [组件类型] 组件名；1.3 修改 alter1.4 查询 show databases；1.5 使用 use 库名；推荐使用 idea 作为开发平台https://www.jetbrains.com/idea/","categories":[{"name":"SQL学习","slug":"SQL学习","permalink":"https://www.thripear.space/categories/SQL%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://www.thripear.space/tags/SQL/"},{"name":"上机","slug":"上机","permalink":"https://www.thripear.space/tags/%E4%B8%8A%E6%9C%BA/"}],"author":"Oliver"},{"title":"Python学习-Chapter7 用户输入和while循环","slug":"Python学习：Chapter 7","date":"2022-11-14T10:43:00.000Z","updated":"2023-04-03T04:53:49.478Z","comments":true,"path":"posts/a93a9fbb.html","link":"","permalink":"https://www.thripear.space/posts/a93a9fbb.html","excerpt":"","text":"Chapter7 用户输入和while循环7.1 input（）字符串输入用户输入文本，把文本呈现给用户 message = input(\"请输入返回的文本：\") print(message) 请输入返回的文本：12345 12345 7.1.1 编写清晰的程序原理： 变量 = input（参数 ：说明/指示） name = input(\"please enter your name:\") print(f\"Hello,{name}\") please enter your name:Oliver Hello,Oliver echo = \"语句1\" #echo = echo + “语句2“ 可以写成： echo += \"语句2\" print(echo) 语句1语句2 7.1.2 int()：将input（）变成int型进行运算age = input(\"What’s your age?:\") age = int(age) print(f\"Your age is {age}\") What’s your age?:65 Your age is 65 7.1.3 求模运算符%作用：将两个数相除并返回余数 如果一个数可被另一个数字整除，%返回值为0 常见用途：判断奇数偶数。 5%3 2 6%3 0 5%1 0 7.2 while循环简介7.2.1 使用while循环语法 while 条件： #注意冒号！！！ 执行块 #注意缩进 7.2.2 设定退出值#空字符串 messag = \"\" #空列表 message = [] #空字典 message = {} while message != 设定值： 执行块 7.2.3 使用标志标志本质上是一个： 变量 用途：判断整个程序是否处于活动状态。 当触发结束条件时，使标志 = false #注意语法： while 标志： 执行块 7.2.4 Break：直接跳出循环语法： while 循环条件： 执行块 if 跳出条件： break 7.2.5 Continue：直接返回开头current_number = 0 while current_number &lt; 10: current_number += 1 if current_number %2 == 0: continue print(current_number) 1 3 5 7 9 7.2.6 避免无限循环注意循环条件不能始终为true 7.3 while处理循环列表和字典7.3.1 在列表间移动元素#当列表为空时，while会认为它是false。 an = [元素1，元素2，元素3···] bn = [] while an: b = an.pop() 对b（an弹出元素的一些操作） bn.append(b) 注意：bn中的顺序是an相反。 7.3.2 while + remove()删除列表中 为某值的 所有元素#注意特殊语法： while 删除元素 in 列表: 列表.remove(删除元素) 7.3.3 用户输入填充字典：#复习语法： 字典插入新的键值对： 字典[新增键] = 新增值 新增值 = input（“提示”） 字典[新增键] = 新增值","categories":[{"name":"Python学习","slug":"Python学习","permalink":"https://www.thripear.space/categories/Python%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.thripear.space/tags/Python/"},{"name":"循环","slug":"循环","permalink":"https://www.thripear.space/tags/%E5%BE%AA%E7%8E%AF/"}],"author":"Oliver"},{"title":"操作系统-Note 1","slug":"操作系统线程","date":"2022-11-13T16:00:00.000Z","updated":"2023-04-03T04:50:54.349Z","comments":true,"path":"posts/df7c6eb3.html","link":"","permalink":"https://www.thripear.space/posts/df7c6eb3.html","excerpt":"","text":"Chapter3: 进程pipes：单项的，双向通信：半双通信，发的时候不能输入，输入时候不能发送。 Chapter4:线程进程间通信 多核编程 1.并行数据并行：数据子集到多核，每个做相同工作 工作并行：线程到每个核，每个核心不同工作 2.用户线程和内核线程用户线程：POSIX Pthreads Windows threads Java threads 内核线程：Windows Solaris LinuxTru64 UNIXMac OS X 操作系统：用户线程看不到，内核线程能看到 用户线程和内核线程对应： 一对一 多对一 多对多 3.Pthreads：函数库 p","categories":[{"name":"操作系统学习","slug":"操作系统学习","permalink":"https://www.thripear.space/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://www.thripear.space/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"author":"Oliver"},{"title":"Python学习-Chapter6 字典","slug":"Python学习：Chapter 6","date":"2022-11-11T07:00:00.000Z","updated":"2023-04-03T04:53:49.477Z","comments":true,"path":"posts/546d0d95.html","link":"","permalink":"https://www.thripear.space/posts/546d0d95.html","excerpt":"","text":"Chapter6: 字典（类比结构体）6.1 一个简单的字典car = {'brand':'bwm','price':1000000,'color':'black'} print(car['brand']) print(car['price']) print(car['color']) bwm 1000000 black 6.2 使用字典6.2.1 定义与访问字典定义： 字典名 = {'键值1':键值1值,'键值2':键值2值···} 访问： 字典名['键值名'] #每一个键值都是一个变量，相当于成员 6.2.2 添加键值对字典['新增键值名'] = 新增键值的值 car = {'brand':'bwm','price':1000000,'color':'black'} print(car)#字典可以直接输出 #新增型号 car['type'] = 'x765' print(car) {'brand': 'bwm', 'price': 1000000, 'color': 'black'} {'brand': 'bwm', 'price': 1000000, 'color': 'black', 'type': 'x765'} 直接打印字典，元素排列顺序和定义时完全相同，用for循环遍历时也按照定义顺序。新增键值对：会直接默认在最后。 6.2.3 创建一个空字典：和创建一个空列表一样 语法： 字典名 = {} 6.2.4 修改字典中的值car = {'brand':'bwm','price':1000000,'color':'black'} car['color'] = 'white' print(car['color']) print(car) white {'brand': 'bwm', 'price': 1000000, 'color': 'white'} 6.2.5 删除键值对：deldel 列表名['键值名'] #键值名记着加引号！！！ car = {'brand':'bwm','price':1000000,'color':'black'} print(car) del car['price'] print(car) {'brand': 'bwm', 'price': 1000000, 'color': 'black'} {'brand': 'bwm', 'color': 'black'} 6.2.6 定义字典小习惯car = {'brand':'bwm', 'price':1000000, 'color':'black'} print(car) #竖着这样写可以让键值对更清晰 {'brand': 'bwm', 'price': 1000000, 'color': 'black'} 6.2.7 使用get()来访问值car = {'brand':'bwm','price':1000000,'color':'black'} print(car.get('brand')) print(car.get('owner')) bwm None 6.3 遍历字典语法： for 键值变量an，键值值bn in 列表名.items(): 执行块 #注意！！！ 列表名.items()不可以省略。items!!! car = {'brand':'bwm','price':1000000,'color':'black'} for key,value in car.items(): print(f\"\\nKey: {key.title()}\") print(f\"\\nValue: {value}\") Key: Brand Value: bwm Key: Price Value: 1000000 Key: Color Value: black 6.3.2 遍历字典中的所有键名变量 或者 键值for 键值变量an in 列表名.keys(): 执行块 .keys()是让前面的变量对应键值名变量。（访问以键值名构成的列表） car = {'brand':'bwm','price':1000000,'color':'black'} for key in car.keys(): print(f\"\\nKey: {key.title()}\") Key: Brand Key: Price Key: Color for 键值变量an in 列表名.values(): 执行块 .values()是让前面的变量对应键值。（访问以键值构成的列表） car = {'brand':'bwm','price':1000000,'color':'black'} for value in car.values(): print(f\"\\nKey: {value}\") Key: bwm Key: 1000000 Key: black 6.3.3 遍历处理后的列表#想按照首字母排序 打印：键值名变量 用sorted（）临时排序 car = {'brand':'bwm','price':1000000,'color':'black'} for key in sorted(car.keys()): print(f\"\\nKey: {key.title()}\") Key: Brand Key: Color Key: Price favo_language = { 'jen': 'python', 'sarah': 'c', 'edward': 'ruby', 'phil': 'python' } print(\"The following languages have been mentioned:\") for language in set(favo_language.values()): print(language.title()) The following languages have been mentioned: Ruby C Python #对列表去重处理： set(列表名) 6.4 嵌套（套娃）6.4.1 6.字典列表car_1 = {'color':'black','price':3000} car_2 = {'color':'whilt','price':34000} car_3 = {'color':'yellow','price':342000} cars = [car_1,car_2,car_3] #注意这里列表用的是方括号 print(cars) for car in cars: print(car) [{'color': 'black', 'price': 3000}, {'color': 'whilt', 'price': 34000}, {'color': 'yellow', 'price': 342000}] {'color': 'black', 'price': 3000} {'color': 'whilt', 'price': 34000} {'color': 'yellow', 'price': 342000} #创建多个的时候可以使用for（） 和 range（） aliens = [] for alien_number in range(0,5): new_alien = {'color':'green','speed':'slow'} aliens.append(new_alien) for alien_number in range(5,30): new_alien = {'color':'yellow','speed':'fast'} aliens.append(new_alien) for alien in aliens[0:30:5]: print(alien) print(len(aliens)) {'color': 'green', 'speed': 'slow'} {'color': 'yellow', 'speed': 'fast'} {'color': 'yellow', 'speed': 'fast'} {'color': 'yellow', 'speed': 'fast'} {'color': 'yellow', 'speed': 'fast'} {'color': 'yellow', 'speed': 'fast'} 30 6.4.2 在字典中储存列表pizza = { 'crust':'thick', 'toppings':['mushrooms','extra cheese'], } for topping in pizza.get('toppings'): #也可以写成 pizza['toppingsb'] print(topping) mushrooms extra cheese 6.4.3 在字典中储存字典pizza = { 'toppings':{'first':'mushrooms','second':'extra cheese'} } for sequence,topping in pizza['toppings'].items(): print(f\"{sequence}: {topping}\") first: mushrooms second: extra cheese","categories":[{"name":"Python学习","slug":"Python学习","permalink":"https://www.thripear.space/categories/Python%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.thripear.space/tags/Python/"},{"name":"字典","slug":"字典","permalink":"https://www.thripear.space/tags/%E5%AD%97%E5%85%B8/"}],"author":"Oliver"},{"title":"Python学习-Chapter5 if语句","slug":"Python学习：Chapter 5","date":"2022-11-09T01:37:00.000Z","updated":"2023-04-03T04:53:49.477Z","comments":true,"path":"posts/e195b2ba.html","link":"","permalink":"https://www.thripear.space/posts/e195b2ba.html","excerpt":"","text":"今天是柴柴的生日！谢谢宝贝蛋的惊喜，开心心！阿狐姐姐辛苦啦❤️Chapter 5 if语句5.1 简单示例cars = ['audi','bmw','subaru','toyota'] for car in cars: if car == 'bmw': print (car.upper()) else: print(car.title()) Audi BMW Subaru Toyota 5.2 条件测试 ：True False5.2.1 检查是否相等my_name = 'oliver' print(my_name == 'oliver') print(my_name == 'taylor') True False 5.2.2检查相等时忽略大小写（字符串）用lower（）cars = ['aUdi','bMw','sUBaru','tOYota'] print(cars[0] == 'audi') print('忽略大小写后，进行四个元素的遍历检查') for car in cars: #用for注意冒号和缩进！ print(car.lower() == 'bmw') print(cars) False 忽略大小写后，进行四个元素的遍历检查 False True False False ['aUdi', 'bMw', 'sUBaru', 'tOYota'] 注意，即使car.lower()，lower（）的返回值是小写，但是对原列表中元素不进行改变。lower()只能用 . 来调用 5.2.3 检查是否不相等使用 !=5.2.4 数值比较&lt; &gt; = != &gt;= &lt;= 返回布尔类型5.2.5 多个条件的检查C语言中 &amp;&amp; 相当于 python的 and || 相当于 or 5.2.6 检查特定值是否在列表中 元素 in 列表cars = ['audi','bmw','subaru','toyota'] check = 'bmw' in cars print(check) True 5.2.7 检查特定值是否 不在 列表中 元素 not in 列表替换上面 in 为 notin 5.3 if语句5.3.1｜5.3.2 if else 语句语法： if 条件: 执行块 else: 执行块 #注意缩进 和 冒号！！！ 有缩进的默认在执行块内 5.3.3 if-elif-else 结构语法： if 条件1: 执行块 elif 条件2: 执行块 else: 执行块 #注意：如果if通过，elif 和 else 全部跳过 # if 没过 elif过了，else跳过 # 其余情况都是else #当if语句中输出字符串出现重复，简化代码小技巧： #eg： age = 12 if age&lt;14: print(\"your admission cost is $0.\") elif age&lt;18: print(\"your admission cost is $25.\") else: print(\"your admission cost is $40.\") your admission cost is $0. #利用f字符串进行简化： age = 12 if age&lt;14: price = 0 elif age&lt;18: price = 25 else: price = 40 print(f\"your admission cost is ${price}.\") your admission cost is 0$. 5.3.4 使用多个elif代码块实现要求收费：4岁以下免费[4,18)岁收25美元；[18,65)岁收40美元；[65,+∞)岁收20美元。 age = 38 if age&lt;4: price = 0 elif age&lt;18: price = 25 elif age&lt;65: price = 40 else: #最后不一定用else结尾，这个可以写成elif price = 20 print(f\"your admission cost is ${price}.\") your admission cost is $40. 5.4 使用if语句处理列表5.4.1 检查特殊元素cars = ['audi','bmw','subaru','toyota'] for car in cars: if car == 'bmw': print(f\"My favorite car is {car}\") My favorite car is bmw 5.4.2 确定列表不是空的cars = [] if cars: #if 列表： 列表为空就为false，反之为true。 print(\"cars\") else: print(\"there is no car in your carlist.\") there is no car in your carlist. 5.4.3 使用多个列表cars = ['audi','bmw','subaru','toyota'] afordable_cars = ['audi','toyota'] for car in cars: if car in afordable_cars: print(f\"The {car} you love is afordable.\")#注意缩进 else: print(f\"You can't buy {car} you love right now.\")#注意这里else和上面的if对齐 The audi you love is afordable. You can't buy bmw you love right now. You can't buy subaru you love right now. The toyota you love is afordable.","categories":[{"name":"Python学习","slug":"Python学习","permalink":"https://www.thripear.space/categories/Python%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.thripear.space/tags/Python/"},{"name":"if语句","slug":"if语句","permalink":"https://www.thripear.space/tags/if%E8%AF%AD%E5%8F%A5/"}],"author":"Oliver"},{"title":"Python学习-Chapter4 操作列表","slug":"Python学习：Chapter 4","date":"2022-11-07T21:48:00.000Z","updated":"2023-04-03T04:53:49.475Z","comments":true,"path":"posts/2fa9e227.html","link":"","permalink":"https://www.thripear.space/posts/2fa9e227.html","excerpt":"","text":"Chapter4 操作列表4.1 for循环的使用4.1.1 这是一个利用循环打印的例子：a = ['a','b','c','d'] for an in a: #冒号必不可少 print(an) a b c d 4.1.2 利用for循环进行更多操作的例子：a = ['a','b','c','d'] for an in a: #冒号必不可少 print(f\"{an.title()} is uppercase of {an}\") print(\"next char is:\\n\") A is uppercase of a next char is: B is uppercase of b next char is: C is uppercase of c next char is: D is uppercase of d next char is: 结果说明： 缩进的都属于for循环 an相当于计数器变量作索引的a[i]。 4.1.2 在for循环结束后执行操作a = ['a','b','c','d'] for an in a: #冒号必不可少 print(f\"{an.title()} is uppercase of {an}\") print(\"test end.\") #当缩进没有的时候，默认为在for循环之外。 A is uppercase of a B is uppercase of b C is uppercase of c D is uppercase of d test end. 4.2 避免缩进错误4.2.1 忘记缩进a = ['a','b','c','d'] for an in a: print(an) File \"/var/folders/1j/k13fttf13b5d6j8_m4q12rgr0000gn/T/ipykernel_49995/1502029580.py\", line 3 print(an) ^ IndentationError: expected an indented block 当没有缩进时，for循环找不到循环体，会报错。 原则：需要进循环体的加缩进，不需要的不加缩进，没有for循环不缩进，for循环不忘冒号4.3 创建数值列表4.3.1 range()和list()range()的三个用法： range(x) 和 range(0,x)一样range(x,y)range(x,y,z) list(range(6)) #相当于默认从0开始数6个 [0, 1, 2, 3, 4, 5] list(range(0,6)) #指定从0开始数6个 [0, 1, 2, 3, 4, 5] list(range(3,12)) #相当于从3到12，步长为1，注意右括号12实际数到11 [3, 4, 5, 6, 7, 8, 9, 10, 11] list(range(3,12,2))#步长为2 [3, 5, 7, 9, 11] 4.3.2 用range()创建数字列表打印1-10的偶数even_num = list(range(2,11,2)) #注意，左边从2开始，右边界限为11（左面取得到，右面够不到） print(even_num) [2, 4, 6, 8, 10] 创建一个列表，包含1-10的平方square_list = [] #先创建一个空列表 for value in range(1,11): square = value ** 2 #每一次线计算一下平方的值，再append到list里面 square_list.append(square) #上面两行可以写成： spuare_list.append(value ** 2) print(square_list) [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 4.3.3 对数字列表执行简单的统计计算找数字列表(元素为数字) 的 最大值、最小值、总和digits = [1,2,3,4,5,6,7,8,9,0] print(max(digits)) print(min(digits)) print(sum(digits)) 9 0 45 4.3.4 列表解析#上面输入平方数的例子还可以用两行代码解决： square_list = [value ** 2 for value in range (1,11)] #本质是把一个列表转换成另一个列表 #格式：列表1 = [表达式 for 变量 in 列表2] print(square_list) [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 4.4 使用列表的一部分使用切片digits = [1,2,3,4,5,6,7,8,9,0] print(digits[0:3]) [1, 2, 3] 切片使用方法： 列表[起点：终点]如果写成 列表[:终点]，起点默认索引为0；如果写成 列表[起点：]，则默认重点到列表最后一个 如何打印最后三个元素？digits = [1,2,3,4,5,6,7,8,9,0] print(digits[-3:]) [8, 9, 0] 列表[-倒数几个：] 每间隔两个元素就提取一个（在选取范围内）digits = [1,2,3,4,5,6,7,8,9,0] print(digits[0:10:2]) [1, 3, 5, 7, 9] [起点：重点：步长]，步长不输入（没有第二个冒号）默认为1. 遍历切片：使用for循环+切片digits = [1,2,3,4,5,6,7,8,9,0] print(\"No 5 to No 9 number in my digits are:\\n\") for digit in digits[4:8]: #利用单复数区别 列表 和 an print(digit)#注意这里打印的是变量 No 5 to No 9 number in my digits are: 5 6 7 8 复制列表 (使用切片)digits = [1,2,3,4,5,6,7,8,9,0] copy_digits = digits[:] digits.append(10) copy_digits.append(11) print(digits) print(copy_digits) [1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 10] [1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 11] 注意语法： 列表1 = 列表2[:]这样才是两个列表 如果没有切片直接复制 则两个列表指向同一个储存空间，本质上是一个列表 digits = [1,2,3,4,5,6,7,8,9,0] copy_digits = digits digits.append(10) copy_digits.append(11) print(digits) print(copy_digits) [1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 10, 11] [1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 10, 11] 4.5 元组-不可改变的列表定义语法：元组名 = (元素1，元素2，…) 访问和列表相同 a = (30,40) print(a[0]) print(a[1]) 30 40 不能改变：指不能单独给其内元素赋值。(报错) a = (30,40) a[0] = 1 --------------------------------------------------------------------------- TypeError Traceback (most recent call last) /var/folders/1j/k13fttf13b5d6j8_m4q12rgr0000gn/T/ipykernel_53119/1136073212.py in &lt;module&gt; 1 a = (30,40) ----&gt; 2 a[0] = 1 TypeError: 'tuple' object does not support item assignment 遍历元组-和for循环a = (30,40,50) for an in a: print(an) 30 40 50 修改元组变量-重新定义a = (30,40) print(a) a = (40,50) print(a) (30, 40) (40, 50)","categories":[{"name":"Python学习","slug":"Python学习","permalink":"https://www.thripear.space/categories/Python%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.thripear.space/tags/Python/"},{"name":"操作列表","slug":"操作列表","permalink":"https://www.thripear.space/tags/%E6%93%8D%E4%BD%9C%E5%88%97%E8%A1%A8/"}],"author":"Oliver"},{"title":"大学物理笔记-1","slug":"大物笔记梳理","date":"2022-11-06T10:00:00.000Z","updated":"2023-04-03T04:53:49.480Z","comments":true,"path":"posts/40d91912.html","link":"","permalink":"https://www.thripear.space/posts/40d91912.html","excerpt":"","text":"前言：破大工又开始搞一些形式主义了，尽量能利用这点破烂时间做点事情。 Why Study Physics?Physics is the branch of science that describes matter, energy, space, and time at the most fundamental level. Fundamental Quantities and Their Dimension物理三大基本量和维度 Length国际标准单位：米 meter Mass国际标准单位：千克 kg Time国际标准单位：秒 s 科学计数法和对应的英语词缀 Conversion of Units &amp; Estimates利用单位守恒判断计算是否正确计算的不确定性： Eg1: 测量初始数据最小分度值必须与仪器相符 Eg2: 利用测量值计算，得到的最大最小结果，分别对应 用的最大最小测量值，对应误差。 当计算时使用的数据有不同精度，采用最粗糙的精度，其余数据四舍五入 Uncertainty in Measurements &amp; Significant Figures计算不确定性解决方案在上一标题 有效数字： 当计算中，出现的数据有不同的有效数字，使用最低位的。 注意： 这几个的有效数字不同 即使含有相同有效数字，数字精确度也不一定相同 出现integer，我们认为其没有精确度 2(int) = 2（准确值） 因为宽是3位有效数字，所以计算结果保留3位有效数字，即44.0 一些粗略估算的例子： Coordinate Systems三角坐标系： 二维情况 将普通坐标系转化成三角坐标系， 注意phi=arctan（y/x） 三维情况：圆柱体坐标系： 多了个z，原坐标系z转化后不变。 球体坐标系：Problem-Solving Strategy流程：identify-set up-execute","categories":[{"name":"大学物理","slug":"大学物理","permalink":"https://www.thripear.space/categories/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/"}],"tags":[{"name":"大学物理","slug":"大学物理","permalink":"https://www.thripear.space/tags/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/"}],"author":"Oliver"},{"title":"Python学习-Chapter3 列表","slug":"Python学习：Chapter 3","date":"2022-11-06T03:48:00.000Z","updated":"2023-04-03T04:53:49.477Z","comments":true,"path":"posts/f12bc114.html","link":"","permalink":"https://www.thripear.space/posts/f12bc114.html","excerpt":"","text":"3.1使用列表中的各个值注意！ 索引可以指定负数！ a=['1','2','3'] print(a[-1]) print(a[-2]) print(a[-3]) 3 2 1 负数即倒数第几个 bicycles = ['trek','cannondale'] message = f\"my bicycle is a {bicycles[1].title()}.\" print(message) my bicycle is a Cannondale. f花括号内可以写变量。 3.2修改列表元素&lt;1&gt;修改其中的元素a=['1','2','3'] print(a) a[0]='4' print(a) ['1', '2', '3'] ['4', '2', '3'] 列表相当于是一个数组 &lt;2&gt;插入元素1 末尾插入：appenda=['1','2','3'] print(a) a.append(\"5\")#注意使用时用.来调用 print(a) ['1', '2', '3'] ['1', '2', '3', '5'] 连续使用append可以连续在后面插入 a=[] print(a) a.append(\"1\") a.append(\"2\") a.append(\"3\") print(a) [] ['1', '2', '3'] 2 选定位置前：inserta=['1','2','3'] print(a) a.insert(0,'han') print(a) ['1', '2', '3'] ['han', '1', '2', '3'] 注意！insert在指定元素 之前 插入！ &lt;3&gt;删除元素1 del 语句 删除 （需要指定索引）a=['1','2','3'] print(a) del a[0] print(a) del a[1] print(a) ['1', '2', '3'] ['2', '3'] ['2'] 2 pop() 删除（）不含任何内容，默认最后一个值被弹出a=['1','2','3'] print(a) poped_a = a.pop() print(a) print(poped_a) ['1', '2', '3'] ['1', '2'] 3 a被pop之后，a最后一个元素被弹出，而a.pop函数返回值就是的被弹出的最后一个元素 指定索引，弹出任意位置处的元素a=['1','2','3'] print(a) poped_a1 = a.pop(1) print(a) print(poped_a1) ['1', '2', '3'] ['1', '3'] 2 根据值删除元素：remove (void返回类型)a=['1','2','3'] print(a) a.remove('2') print(a) ['1', '2', '3'] ['1', '3'] 3.3 组织列表sort() 对列表永久排序(首字母顺序)a = ['c','b','z','a','d'] print(a) a.sort() print(f\"\\n{a}\") #如果想要反向排序，使用sort(reverse=True) a.sort(reverse=True) print(f\"\\n{a}\") #注意： print(a.sort()) #该语句不是打印a.sort（）后的 a,而是a.sort()函数的返回值，void无返回值。 #所以先进行排序，后print。 ['c', 'b', 'z', 'a', 'd'] ['a', 'b', 'c', 'd', 'z'] ['z', 'd', 'c', 'b', 'a'] None sorted() 对列表临时排序a = ['c','b','z','a','d'] print(a) print(\"\\n临时排序后的列表：\") print(sorted(a)) print(\"\\n再输出原来的列表：\") print(a) ['c', 'b', 'z', 'a', 'd'] 临时排序后的列表： ['a', 'b', 'c', 'd', 'z'] 再输出原来的列表： ['c', 'b', 'z', 'a', 'd'] 注意：sorted()使用语法：sorted(列表) 我们使用的是sorted的返回值（列表类），而sort对原列表不会有任何修改。 reverse() 对列表永久 原顺序反转a = ['c','b','z','a','d'] print(a) a.reverse() print(f\"\\n{a}\") ['c', 'b', 'z', 'a', 'd'] ['d', 'a', 'z', 'b', 'c'] len() 确定列表长度a = ['c','b','z','a','d'] print(len(a)) print(\"\\n试图给b赋予a的长度：\") b = len(a) print(f\"a的长度是：{b}\") 5 试图给b赋予a的长度： a的长度是：5 3.4 避免索引错误当出现循环时，可以使用len()知道长度，保证索引&lt;len()的值，注意len（）不能直接用","categories":[{"name":"Python学习","slug":"Python学习","permalink":"https://www.thripear.space/categories/Python%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.thripear.space/tags/Python/"},{"name":"列表","slug":"列表","permalink":"https://www.thripear.space/tags/%E5%88%97%E8%A1%A8/"}],"author":"Oliver"},{"title":"阿狐和我的小纸条","slug":"阿狐的纸条","date":"2022-05-20T16:05:21.000Z","updated":"2023-04-03T04:49:36.104Z","comments":true,"path":"posts/3cb2d2bc.html","link":"","permalink":"https://www.thripear.space/posts/3cb2d2bc.html","excerpt":"","text":"March9th MarThe distance between us is breaking my spirit. My time and experiences without you are meaningless to me.🌹 谢谢你，让我知道原来世界上，真的有人那么可爱！晚上要好好学习，我喜欢你为梦想努力的样子！如果我是那只路过的玫瑰也没关系，只希望，送给你花香，不会刺伤你。🌟 10th Mar U had me at “hello”Your destiny was entwined with mine! 即使带着命运的陆离光怪，理应属于你的幸运也会让时间给予偏爱。🌼 等你下课哟！我也开始工作啦！😘 从这个春天开始，我们的人生，全糖去冰哦🌟 11th Mar 做你的猫～～ 玫瑰花，要你捧的才浪漫！ 人生，要和你才精彩！😘 12th Mar 爱不一定是在你春风得意的时候出现。所以，我们苦了太久了，才得到相遇的机会。我们的甜蜜，和上帝的旨意无关，是我们彼此之间汹涌的爱，让我们再次勇敢。乖乖，不要怕，我在爱你！我们只需要把握当下，向前看，风霜与共！我奉陪到底哟！😘 14th Mar 我的存在是一串代码，我的使命是爱你。 我的春日限定：玫瑰和oliver！ 15th Mar 南风知我意，吹梦到西洲。 刚刚收到雅诗兰黛粉底液，上面的广告语： 去爱一个能够让你做回小朋友的人，而不是去爱一个总是嫌弃你不懂事的人。 （没错，就是你啦！准确是我们彼此啦！） 16th Mar 我刚好在，你刚好来。 我在等，世上唯一契合的灵魂。 to Oliver 17th Mar 不求被全世界宠爱，只求一生是你一个人的例外！ 我会陪着你的，要相信自己，加油！ 18th Mar 我真的好快乐啊！！！谢谢你 19th Mar 那么，我们在这个夏天，见一面吧！ 20th Mar 期待夏天🌟 热吻 啤酒 街头 耳机里的音乐 live现场 浪漫的一切💑 包括最爱的人🦄️ 21th Mar 一起向前的感觉，真的太棒了！ 欢迎你，我的人生合伙人！🌟 25th Mar 后知后觉，没关系呀！我们不是一直在相爱吗？👌 27th Mar 想你想你想你想你想你想你想你想你想你想你想你想你想你想你想你想你想你 April6th Apr 与你四目相对是一场心脏盛宴 我爱你❤️ 9th Apr你就站在那里，就已让我看不到任何人！❤️🍑 13th Apr 真正的爱，甜是主基调，但无法避免那些咸咸的眼泪。 宝贝，我们在这份爱的笼罩下，成为更好的人。 我们会吵架，可是我们都会低头。 因为，问题是我们和问题的对抗， 不是我和你之间的问题。 所以，苏苏今天更爱你了😘 16th Apr 你是我最大的底气🐶❤️🦊 苏苏的世界，如果没有三月， 那人间的别称就是地狱💖 18th Apr HYD简直是人间理想💓💓💓💓💓😘 20th Apr 如果这份爱意让你差异，其实我才是那个被吓坏的人，我从没有傻到会相信，一个人会在另一个人身上找到所有他期望的。 但在你身上我找到了所有。 25th Apr 今天晚上哟！ 爱你😘 May3rd May 请用： ​ 以后、我们、故事三个词造句。 我的是：💖 以后的故事，都是关于我们。🦊 4th May 课上瞌睡10分钟，梦到你了嘻嘻😜💓 13th May 我最骄傲的事，是被你深爱着。 💓你，是我面对一切的底气。💖 June3rd JuneH先生，现在我要以心动杀人，逮捕你。💓 🆘🆘🆘🆘🆘 5th June 少年披着夏天的外套，清清楚楚地说着只爱我🎉🤪","categories":[{"name":"小日常","slug":"小日常","permalink":"https://www.thripear.space/categories/%E5%B0%8F%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://www.thripear.space/tags/%E6%97%A5%E5%B8%B8/"},{"name":"小纸条","slug":"小纸条","permalink":"https://www.thripear.space/tags/%E5%B0%8F%E7%BA%B8%E6%9D%A1/"}],"author":"Oliver"},{"title":"我们的历程","slug":"我们的历程","date":"2022-05-19T16:05:20.000Z","updated":"2023-04-03T04:53:49.480Z","comments":true,"path":"posts/a826af6d.html","link":"","permalink":"https://www.thripear.space/posts/a826af6d.html","excerpt":"","text":"Feburary相遇到底是缘分的命中注定，还是命运的欲盖弥彰，我想听你说， March希望之前没来的好运在春天出现，希望拙劣的文笔也能将心意传达，希望我喜欢的你喜欢我，希望希望的事成真。 April21st April 我陪月亮熬夜，星星陪我想你，而风和思念都很喧器。你要相信不管是命运的安排，还是时光的眷顾，你我都是最登对的人．你要相信我. 25th April6:37 A.M. 醒来的时候，特别想去见你，所以．渡江跨河，翻山越岭、两干公里算什么，我来啦 8:10 P.M.落地 ✈️ 胶东国际机场 我见过没有风的大海，看过迷雾笼罩的森林，但都不及我第一次遇见你。 在机场，我看着你，这世间犹如银幕年代的默剧，只有心跳陪我演出，而爱神在你身后，向我示意。 那一刻，我的心发出响彻灵魂的轰鸣，原来这就是人们说的一见钟情。💘 接下来，幸福变成了脂肪（呃呃，打嗝声哈哈哈)，我胖了6斤. May2nd May撤退啦！这座城市里有我的秘密和我爱的人，从此我不再追寻光消失的天际,因为我已经找到心中耀眼的光. 19th May我后怕.如果当初走得快些或慢些如果当初稍作停留或不曾离开，如果假设的事情发生，将永失我爱此时，你我时光正好。 20th May理性带来寂寞，感性产出错觉，爱情，也只有你能够给我.你是我藏在文字中独一无二的意中人。HYD","categories":[{"name":"记录","slug":"记录","permalink":"https://www.thripear.space/categories/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"历程","slug":"历程","permalink":"https://www.thripear.space/tags/%E5%8E%86%E7%A8%8B/"},{"name":"日常","slug":"日常","permalink":"https://www.thripear.space/tags/%E6%97%A5%E5%B8%B8/"}],"author":"Oliver"},{"title":"第一次为你提笔-柴柴","slug":"第一次为你提笔柴柴","date":"2022-05-19T16:00:00.000Z","updated":"2023-04-03T04:53:49.480Z","comments":true,"path":"posts/f433ca80.html","link":"","permalink":"https://www.thripear.space/posts/f433ca80.html","excerpt":"","text":"我是凡夫俗子，笔尖流不出华丽的词藻。 因为你贫瘠土壤开出了文字的花。 我们都不想长大。 饱食人间烟火，心却不曾沾染凡俗之气。 我爱你，你是我生存的原因。","categories":[{"name":"记录","slug":"记录","permalink":"https://www.thripear.space/categories/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"提笔","slug":"提笔","permalink":"https://www.thripear.space/tags/%E6%8F%90%E7%AC%94/"},{"name":"记录","slug":"记录","permalink":"https://www.thripear.space/tags/%E8%AE%B0%E5%BD%95/"}],"author":"Oliver"},{"title":"第一次为你提笔-阿狐","slug":"第一次为你提笔阿狐","date":"2022-05-19T16:00:00.000Z","updated":"2023-04-03T04:53:49.480Z","comments":true,"path":"posts/732b7af7.html","link":"","permalink":"https://www.thripear.space/posts/732b7af7.html","excerpt":"","text":"我坚信命运总是将我们往正确的人那里推。有人，得天独厚，年少相逢，未曾珍惜错失；有人，跌跌撞撞，终其一生，至死不可得。我曾凭着一腔热血，莽撞，视死如归。却发现你是我藏在发霉枕头下，日复一日的春秋大梦。在春日深夜被泪打湿的枕头，在夏日阳光下拿出暴晒，试图驱散那些阴霾。在秋日落叶中望着那些斑驳泪渍。却在冬日里，枕着那些遗憾，做了一个美梦。温柔，浪漫至死的我们，拼命找，却遍体鳞伤，但一个侧身，找到真正的归途。真正的爱浮现地那一刻，我们原谅了那些过往，又生出无限的勇气，为彼此而重新生长。","categories":[{"name":"记录","slug":"记录","permalink":"https://www.thripear.space/categories/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://www.thripear.space/tags/%E6%97%A5%E5%B8%B8/"},{"name":"记录","slug":"记录","permalink":"https://www.thripear.space/tags/%E8%AE%B0%E5%BD%95/"}],"author":"Oliver"}],"categories":[{"name":"Summerschool","slug":"Summerschool","permalink":"https://www.thripear.space/categories/Summerschool/"},{"name":"卷积神经网络","slug":"卷积神经网络","permalink":"https://www.thripear.space/categories/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://www.thripear.space/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"SQL学习","slug":"SQL学习","permalink":"https://www.thripear.space/categories/SQL%E5%AD%A6%E4%B9%A0/"},{"name":"Python学习","slug":"Python学习","permalink":"https://www.thripear.space/categories/Python%E5%AD%A6%E4%B9%A0/"},{"name":"操作系统学习","slug":"操作系统学习","permalink":"https://www.thripear.space/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"},{"name":"大学物理","slug":"大学物理","permalink":"https://www.thripear.space/categories/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/"},{"name":"小日常","slug":"小日常","permalink":"https://www.thripear.space/categories/%E5%B0%8F%E6%97%A5%E5%B8%B8/"},{"name":"记录","slug":"记录","permalink":"https://www.thripear.space/categories/%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.thripear.space/tags/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"https://www.thripear.space/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"计算机视觉","slug":"计算机视觉","permalink":"https://www.thripear.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://www.thripear.space/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"SQL","slug":"SQL","permalink":"https://www.thripear.space/tags/SQL/"},{"name":"理论","slug":"理论","permalink":"https://www.thripear.space/tags/%E7%90%86%E8%AE%BA/"},{"name":"上机","slug":"上机","permalink":"https://www.thripear.space/tags/%E4%B8%8A%E6%9C%BA/"},{"name":"循环","slug":"循环","permalink":"https://www.thripear.space/tags/%E5%BE%AA%E7%8E%AF/"},{"name":"操作系统","slug":"操作系统","permalink":"https://www.thripear.space/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"字典","slug":"字典","permalink":"https://www.thripear.space/tags/%E5%AD%97%E5%85%B8/"},{"name":"if语句","slug":"if语句","permalink":"https://www.thripear.space/tags/if%E8%AF%AD%E5%8F%A5/"},{"name":"操作列表","slug":"操作列表","permalink":"https://www.thripear.space/tags/%E6%93%8D%E4%BD%9C%E5%88%97%E8%A1%A8/"},{"name":"大学物理","slug":"大学物理","permalink":"https://www.thripear.space/tags/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/"},{"name":"列表","slug":"列表","permalink":"https://www.thripear.space/tags/%E5%88%97%E8%A1%A8/"},{"name":"日常","slug":"日常","permalink":"https://www.thripear.space/tags/%E6%97%A5%E5%B8%B8/"},{"name":"小纸条","slug":"小纸条","permalink":"https://www.thripear.space/tags/%E5%B0%8F%E7%BA%B8%E6%9D%A1/"},{"name":"历程","slug":"历程","permalink":"https://www.thripear.space/tags/%E5%8E%86%E7%A8%8B/"},{"name":"提笔","slug":"提笔","permalink":"https://www.thripear.space/tags/%E6%8F%90%E7%AC%94/"},{"name":"记录","slug":"记录","permalink":"https://www.thripear.space/tags/%E8%AE%B0%E5%BD%95/"}]}